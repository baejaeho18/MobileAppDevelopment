[{"exampleDescription":"","name":"J2EE Misconfiguration: Data Transmission Without Encryption","childOf":[319],"description":"Information sent over a network can be compromised while in transit. An attacker may be able to read or modify the contents if the data are sent in plaintext or are weakly encrypted. ","parentOf":[],"id":5,"memberOf":[],"exampleCode":[]},{"exampleDescription":"Example 1\nThe following XML example code is a deployment descriptor for a Java web application deployed on a Sun Java Application Server. This deployment descriptor includes a session configuration property for configuring the session ID length.\nThis deployment descriptor has set the session ID length for this Java web application to 8 bytes (or 64 bits). The session ID length for Java web applications should be set to 16 bytes (128 bits) to prevent attackers from guessing and\/or stealing a session ID and taking over a user's session.\nNote for most application servers including the Sun Java Application Server the session ID length is by default set to 128 bits and should not be changed. And for many application servers the session ID length cannot be changed from this default setting. Check your application server documentation for the session ID length default setting and configuration options to ensure that the session ID length is set to 128 bits.\n","name":"J2EE Misconfiguration: Insufficient Session","childOf":[334],"description":"The J2EE application is configured to use an insufficient session ID length. If an attacker can guess or steal a session ID, then they may be able to take over the user's session (called session hijacking). The number of possible session IDs increases with increased session ID length, making it more difficult to guess or steal a session ID.","parentOf":[],"id":6,"memberOf":[1018],"exampleCode":[" XML\n   \n  \n  \n   \n    <sun-web-app>\n    \n     \n      ...\n<session-config>\n      \n       \n        <session-properties>\n        \n         <property name=\"idLengthBytes\" value=\"8\">\n         \n          <description>The number of bytes in this web module's session ID.<\/description>\n         <\/property>\n        <\/session-properties>\n       \n      <\/session-config>\n...\n     \n    <\/sun-web-app>\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the snippet below, an unchecked runtime exception thrown from within the try block may cause the container to display its default error page (which may contain a full stack trace, among other things).\n","name":"J2EE Misconfiguration: Missing Custom Error Page","childOf":[756],"description":"The default error page of a web application should not display sensitive information about the software system. A Web application must define a default error page for 4xx errors (e.g. 404), 5xx (e.g. 500) errors and catch java.lang.Throwable exceptions to prevent attackers from mining information from the application container's built-in error response. When an attacker explores a web site looking for vulnerabilities, the amount of information that the site provides is crucial to the eventual success or failure of any attempted attacks.","parentOf":[],"id":7,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    Public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \n     try {\n     \n      ...\n     } catch (ApplicationSpecificException ase) {\n     \n      logger.error(\"Caught"]},{"exampleDescription":"Example 1\nedit-config.pl: This CGI script is used to modify settings in a configuration file.\nThe script intends to take the 'action' parameter and invoke one of a variety of functions based on the value of that parameter - config_file_add_key(), config_file_set_key(), or config_file_delete_key(). It could set up a conditional to invoke each function separately, but eval() is a powerful way of doing the same thing in fewer lines of code, especially when a large number of functions or variables are involved. Unfortunately, in this case, the attacker can provide other values in the action parameter, such as:\nThis would produce the following string in handleConfigAction():\nAny arbitrary Perl code could be added after the attacker has \"closed off\" the construction of the original function call, in order to prevent parsing errors from causing the malicious eval() to fail before the attacker's payload is activated. This particular manipulation would fail after the system() call, because the \"_key(\\$fname, \\$key, \\$val)\" portion of the string would cause an error, but this is irrelevant to the attack because the payload has already been activated.\n","name":"Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')","childOf":[94],"description":"The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. \"eval\"). This may allow an attacker to execute arbitrary code, or at least modify what code can be executed.","parentOf":[],"id":95,"memberOf":[1019],"exampleCode":[" Perl\n   \n  \n  \n   \n    use CGI qw("]},{"exampleDescription":"Example 1\nTwo validation forms with the same name.\nIt is critically important that validation logic be maintained and kept in sync with the rest of the application.\n","name":"Struts: Duplicate Validation Forms","childOf":[1173,20],"description":"The application uses multiple validation forms with the same name, which might cause the Struts Validator to validate a form that the programmer does not expect. If two validation forms have the same name, the Struts Validator arbitrarily chooses one of the forms to use for input validation and discards the other. This decision might not correspond to the programmer's expectations, possibly leading to resultant weaknesses. Moreover, it indicates that the validation logic is not up-to-date, and can indicate that other, more subtle validation errors are present.","parentOf":[],"id":102,"memberOf":[],"exampleCode":[" XML\n   \n  \n  \n   \n    <form-validation>\n    \n     <formset>\n     \n      <form name=\"ProjectForm\"> ... <\/form>\n<form name=\"ProjectForm\"> ... <\/form>\n     <\/formset>\n    <\/form-validation>\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following Java example the class RegistrationForm is a Struts framework ActionForm Bean that will maintain user input data from a registration webpage for an online business site. The user will enter registration data and the RegistrationForm bean in the Struts framework will maintain the user data. Tthe RegistrationForm class implements the validate method to validate the user input entered into the form.\nAlthough the validate method is implemented in this example the method does not call the validate method of the ValidatorForm parent class with a call super.validate(). Without the call to the parent validator class only the custom validation will be performed and the default validation will not be performed. The following example shows that the validate method of the ValidatorForm class is called within the implementation of the validate method.\n","name":"Struts: Incomplete validate() Method Definition","childOf":[573,20],"description":"The application has a validator form that either does not define a validate() method, or defines a validate() method but does not call super.validate(). If the code does not call super.validate(), the Validation Framework cannot check the contents of the form against a validation form. In other words, the validation framework will be disabled for the given form.","parentOf":[],"id":103,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class RegistrationForm extends org.apache.struts.validator.ValidatorForm {\n\n    \n     \/\/ private variables for registration form\nprivate String name;\nprivate String email;\n...\n \npublic RegistrationForm() {\n     \n      super();\n     }\n \npublic ActionErrors validate(ActionMapping mapping, HttpServletRequest request) {\n     \n      ActionErrors errors = new ActionErrors();\nif (getName() == null || getName().length() < 1) {\n      \n       errors.add(\"name\", new ActionMessage(\"error.name.required\"));\n      }\nreturn errors;\n     }\n     \n\n    \n     \/\/ getter and setter methods for private variables\n...\n     \n}\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following Java example the class RegistrationForm is a Struts framework ActionForm Bean that will maintain user information from a registration webpage for an online business site. The user will enter registration data and through the Struts framework the RegistrationForm bean will maintain the user data.\nHowever, the RegistrationForm class extends the Struts ActionForm class which does not allow the RegistrationForm class to use the Struts validator capabilities. When using the Struts framework to maintain user data in an ActionForm Bean, the class should always extend one of the validator classes, ValidatorForm, ValidatorActionForm, DynaValidatorForm or DynaValidatorActionForm. These validator classes provide default validation and the validate method for custom validation for the Bean object to use for validating input data. The following Java example shows the RegistrationForm class extending the ValidatorForm class and implementing the validate method for validating input data.\nNote that the ValidatorForm class itself extends the ActionForm class within the Struts framework API.\n","name":"Struts: Form Bean Does Not Extend Validation Class","childOf":[573,20],"description":"If a form bean does not extend an ActionForm subclass of the Validator framework, it can expose the application to other weaknesses related to insufficient input validation. ","parentOf":[],"id":104,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class RegistrationForm extends org.apache.struts.action.ActionForm {\n\n    \n     \n      \/\/ private variables for registration form\nprivate String name;\nprivate String email;\n...\n \npublic RegistrationForm() {\n      \n       super();\n      }\n \n\/\/ getter and setter methods for private variables\n...\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following example the Java class RegistrationForm is a Struts framework ActionForm Bean that will maintain user input data from a registration webpage for an online business site. The user will enter registration data and, through the Struts framework, the RegistrationForm bean will maintain the user data in the form fields using the private member variables. The RegistrationForm class uses the Struts validation capability by extending the ValidatorForm class and including the validation for the form fields within the validator XML file, validator.xml.\nThe validator XML file, validator.xml, provides the validation for the form fields of the RegistrationForm.\nHowever, in the previous example the validator XML file, validator.xml, does not provide validators for all of the form fields in the RegistrationForm. Validator forms are only provided for the first five of the seven form fields. The validator XML file should contain validator forms for all of the form fields for a Struts ActionForm bean. The following validator.xml file for the RegistrationForm class contains validator forms for all of the form fields.\n","name":"Struts: Form Field Without Validator","childOf":[1173,20],"description":"The application has a form field that is not validated by a corresponding validation form, which can introduce other weaknesses related to insufficient input validation. Omitting validation for even a single input field may give attackers the leeway they need to compromise the application. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.","parentOf":[],"id":105,"memberOf":[],"exampleCode":[" XML\n   \n  \n  \n   \n    <form-validation>\n    \n     <formset>\n     \n      <form name=\"RegistrationForm\">\n      \n       <field property=\"name\" depends=\"required\">\n       \n        <arg position=\"0\" key=\"prompt.name\"\/>\n       <\/field>\n<field property=\"address\" depends=\"required\">\n       \n        <arg position=\"0\" key=\"prompt.address\"\/>\n       <\/field>\n<field property=\"city\" depends=\"required\">\n       \n        <arg position=\"0\" key=\"prompt.city\"\/>\n       <\/field>\n<field property=\"state\" depends=\"required,mask\">\n       \n        <arg position=\"0\" key=\"prompt.state\"\/>\n<var>\n        \n         <var-name>mask<\/var-name>\n<var-value>[a-zA-Z]{2}<\/var-value>\n        <\/var>\n       <\/field>\n<field property=\"zipcode\" depends=\"required,mask\">\n       \n        <arg position=\"0\" key=\"prompt.zipcode\"\/>\n<var>\n        \n         <var-name>mask<\/var-name>\n<var-value>\\d{5}<\/var-value>\n        <\/var>\n       <\/field>\n      <\/form>\n     <\/formset>\n    <\/form-validation>\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following Java example the class RegistrationForm is a Struts framework ActionForm Bean that will maintain user input data from a registration webpage for an online business site. The user will enter registration data and, through the Struts framework, the RegistrationForm bean will maintain the user data.\nHowever, the RegistrationForm class extends the Struts ActionForm class which does use the Struts validator plug-in to provide validator capabilities. In the following example, the RegistrationForm Java class extends the ValidatorForm and Struts configuration XML file, struts-config.xml, instructs the application to use the Struts validator plug-in.\nThe plug-in tag of the Struts configuration XML file includes the name of the validator plug-in to be used and includes a set-property tag to instruct the application to use the file, validator-rules.xml, for default validation rules and the file, validation.XML, for custom validation.\n","name":"Struts: Plug","childOf":[1173,20],"description":"When an application does not use an input validation framework such as the Struts Validator, there is a greater risk of introducing weaknesses related to insufficient input validation. Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input leads to cross-site scripting, process control, and SQL injection vulnerabilities, among others. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.","parentOf":[],"id":106,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class RegistrationForm extends org.apache.struts.action.ActionForm {\n    \n \/\/ private variables for registration form \nprivate String name;\nprivate String email;\n...\n \npublic RegistrationForm() {\n     \n      super();\n     }\n \n \/\/ getter and setter methods for private variables \n...\n\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following example the class RegistrationForm is a Struts framework ActionForm Bean that will maintain user input data from a registration webpage for an online business site. The user will enter registration data and, through the Struts framework, the RegistrationForm bean will maintain the user data in the form fields using the private member variables. The RegistrationForm class uses the Struts validation capability by extending the ValidatorForm class and including the validation for the form fields within the validator XML file, validator.xml.\nHowever, the validator XML file, validator.xml, for the RegistrationForm class includes the validation form for the user input form field \"phone\" that is no longer used by the input form and the RegistrationForm class. Any validation forms that are no longer required should be removed from the validator XML file, validator.xml.\nThe existence of unused forms may be an indication to attackers that this code is out of date or poorly maintained.\n","name":"Struts: Unused Validation Form","childOf":[1164,20],"description":"An unused validation form indicates that validation logic is not up-to-date. It is easy for developers to forget to update validation logic when they remove or rename action form mappings. One indication that validation logic is not being properly maintained is the presence of an unused validation form.","parentOf":[],"id":107,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class RegistrationForm extends org.apache.struts.validator.ValidatorForm {\n\n    \n     \n \/\/ private variables for registration form \nprivate String name;\nprivate String address;\nprivate String city;\nprivate String state;\nprivate String zipcode;\n \/\/ no longer using the phone form field \n \n \/\/ private String phone; \nprivate String email;\n \npublic RegistrationForm() {\n      \n       super();\n      }\n \n \/\/ getter and setter methods for private variables \n...\n     \n    }\n   \n  \n \n"," XML\n   \n  \n  \n   \n    <form-validation>\n    \n     \n      <formset>\n      \n       \n        <form name=\"RegistrationForm\">\n        \n         \n          <field property=\"name\" depends=\"required\">\n          \n           <arg position=\"0\" key=\"prompt.name\"\/>\n          <\/field>\n<field property=\"address\" depends=\"required\">\n          \n           <arg position=\"0\" key=\"prompt.address\"\/>\n          <\/field>\n<field property=\"city\" depends=\"required\">\n          \n           <arg position=\"0\" key=\"prompt.city\"\/>\n          <\/field>\n<field property=\"state\" depends=\"required,mask\">\n          \n           <arg position=\"0\" key=\"prompt.state\"\/>\n<var>\n           \n            <var-name>mask<\/var-name>\n<var-value>[a-zA-Z]{2}<\/var-value>\n           <\/var>\n          <\/field>\n<field property=\"zipcode\" depends=\"required,mask\">\n          \n           <arg position=\"0\" key=\"prompt.zipcode\"\/>\n<var>\n           \n            <var-name>mask<\/var-name>\n<var-value>\\d{5}<\/var-value>\n           <\/var>\n          <\/field>\n<field property=\"phone\" depends=\"required,mask\">\n          \n           <arg position=\"0\" key=\"prompt.phone\"\/>\n<var>\n           \n            <var-name>mask<\/var-name>\n<var-value>^([0-9]{3})(-)([0-9]{4}|[0-9]{4})$<\/var-value>\n           <\/var>\n          <\/field>\n<field property=\"email\" depends=\"required,email\">\n          \n           <arg position=\"0\" key=\"prompt.email\"\/>\n          <\/field>\n         \n        <\/form>\n       \n      <\/formset>\n     \n    <\/form-validation>\n   \n  \n \n"]},{"exampleDescription":"","name":"Struts: Unvalidated Action Form","childOf":[1173,20],"description":"Every Action Form must have a corresponding validation form. If a Struts Action Form Mapping specifies a form, it must have a validation form defined under the Struts Validator.","parentOf":[],"id":108,"memberOf":[],"exampleCode":[]},{"exampleDescription":"Example 1\nThis mapping defines an action for a download form:\nThis mapping has disabled validation. Disabling validation exposes this action to numerous types of attacks.\n","name":"Struts: Validator Turned Off","childOf":[1173,20],"description":"Automatic filtering via a Struts bean has been turned off, which disables the Struts Validator and custom validation logic. This exposes the application to other weaknesses related to insufficient input validation. ","parentOf":[],"id":109,"memberOf":[],"exampleCode":[" XML\n   \n  \n  \n   \n    <action path=\"\/download\"\ntype=\"com.website.d2.action.DownloadAction\"\nname=\"downloadForm\"\nscope=\"request\"\ninput=\".download\"\nvalidate=\"false\">\n<\/action>\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThis example shows an inconsistency between an action form and a validation form. with a third field.\nThis first block of code shows an action form that has two fields, startDate and endDate.\nThis second block of related code shows a validation form with a third field: scale. The presence of the third field suggests that DateRangeForm was modified without taking validation into account.\n","name":"Struts: Validator Without Form Field","childOf":[1164,20],"description":"Validation fields that do not appear in forms they are associated with indicate that the validation logic is out of date. It is easy for developers to forget to update validation logic when they make changes to an ActionForm class. One indication that validation logic is not being properly maintained is inconsistencies between the action form and the validation form. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.","parentOf":[],"id":110,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class DateRangeForm extends ValidatorForm {\n    \n     \n      String startDate, endDate;\n \npublic void setStartDate(String startDate) {\n      \n       this.startDate = startDate;\n      }\n \npublic void setEndDate(String endDate) {\n      \n       this.endDate = endDate;\n      }\n     \n    }\n   \n  \n \n"," XML\n   \n  \n  \n   \n    <form name=\"DateRangeForm\">\n    \n     <field property=\"startDate\" depends=\"date\">\n     \n      <arg0 key=\"start.date\"\/>\n     <\/field>\n<field property=\"endDate\" depends=\"date\">\n     \n      <arg0 key=\"end.date\"\/>\n     <\/field>\n<field property=\"scale\" depends=\"integer\">\n     \n      <arg0 key=\"range.scale\"\/>\n     <\/field>\n    <\/form>\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following code defines a class named Echo. The class declares one native method (defined below), which uses C to echo commands entered on the console back to the user. The following C code defines the native method implemented in the Echo class:\nBecause the example is implemented in Java, it may appear that it is immune to memory issues like buffer overflow vulnerabilities. Although Java does do a good job of making memory operations safe, this protection does not extend to vulnerabilities occurring in source code written in other languages that are accessed using the Java Native Interface. Despite the memory protections offered in Java, the C code in this example is vulnerable to a buffer overflow because it makes use of gets(), which does not check the length of its input.\nThe Sun Java(TM) Tutorial provides the following description of JNI [See Reference]: The JNI framework lets your native method utilize Java objects in the same way that Java code uses these objects. A native method can create Java objects, including arrays and strings, and then inspect and use these objects to perform its tasks. A native method can also inspect and use objects created by Java application code. A native method can even update Java objects that it created or that were passed to it, and these updated objects are available to the Java application. Thus, both the native language side and the Java side of an application can create, update, and access Java objects and then share these objects between them.\nThe vulnerability in the example above could easily be detected through a source code audit of the native method implementation. This may not be practical or possible depending on the availability of the C source code and the way the project is built, but in many cases it may suffice. However, the ability to share objects between Java and native methods expands the potential risk to much more insidious cases where improper data handling in Java may lead to unexpected vulnerabilities in native code or unsafe operations in native code corrupt data structures in Java. Vulnerabilities in native code accessed through a Java application are typically exploited in the same manner as they are in applications written in the native language. The only challenge to such an attack is for the attacker to identify that the Java application uses native code to perform certain operations. This can be accomplished in a variety of ways, including identifying specific behaviors that are often implemented with native code or by exploiting a system information exposure in the Java application that reveals its use of JNI [See Reference].\n","name":"Direct Use of Unsafe JNI","childOf":[695,20],"description":"When a Java application uses the Java Native Interface (JNI) to call code written in another programming language, it can expose the application to weaknesses in that code, even if those weaknesses cannot occur in Java. Many safety features that programmers may take for granted do not apply for native code, so you must carefully review all such code for potential problems. The languages used to implement native code may be more susceptible to buffer overflows and other attacks. Native code is unprotected by the security features enforced by the runtime environment, such as strong typing and array bounds checking.","parentOf":[],"id":111,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    class Echo {\n    \n     \npublic native void runEcho();\nstatic {\n      \n       \nSystem.loadLibrary(\"echo\");\n       \n      }\npublic static void main(String[] args) {\n      \n       \nnew Echo().runEcho();\n       \n      }\n     \n    }\n   \n  \n \n"," C\n   \n  \n  \n   \n    #include <jni.h>\n#include \"Echo.h\"\/\/the java class above compiled with javah\n#include <stdio.h>\n \nJNIEXPORT void JNICALL\nJava_Echo_runEcho(JNIEnv *env, jobject obj)\n{\n    \n     char buf[64];\ngets(buf);\nprintf(buf);\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following example subtracts from a 32 bit signed integer.\nThe example has an integer underflow. The value of i is already at the lowest negative value possible, so after subtracting 1, the new value of i is 2147483647.\nExample 2\nThis code performs a stack allocation based on a length calculation.\nSince a and b are declared as signed ints, the \"a - b\" subtraction gives a negative result (-1). However, since len is declared to be unsigned, len is cast to an extremely large positive number (on 32-bit systems - 4294967295). As a result, the buffer buf[len] declaration uses an extremely large size to allocate on the stack, very likely more than the entire computer's memory space.\nMiscalculations usually will not be so obvious. The calculation will either be complicated or the result of an attacker's input to attain the negative value.\n","name":"Integer Underflow (Wrap or Wraparound)","childOf":[682,682],"description":"The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result. This can happen in signed and unsigned cases.","parentOf":[],"id":191,"memberOf":[189],"exampleCode":[" C\n   \n  \n  \n   \n    #include <stdio.h>\n#include <stdbool.h>\nmain (void)\n{\n    \n     int i;\ni = -2147483648;\ni = i - 1;\nreturn 0;\n    }\n\n   \n  \n \n"," C\n   \n  \n  \n   \n    int a = 5, b = 6;\n size_t len = a - b;\n char buf[len]; \/\/ Just blows up the stack\n    }\n  \n \n"]},{"exampleDescription":"Example 1\nThe following code is intended to read an incoming packet from a socket and extract one or more headers.\nThe code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow.\nExample 2\nThe following code reads a maximum size and performs validation on that size. It then performs a strncpy, assuming it will not exceed the boundaries of the array. While the use of \"short s\" is forced in this particular example, short int's are frequently used within real-world code, such as code that processes structured data.\nThis code first exhibits an example of CWE-839, allowing \"s\" to be a negative number. When the negative short \"s\" is converted to an unsigned integer, it becomes an extremely large positive integer. When this converted integer is used by strncpy() it will lead to a buffer overflow (CWE-119).\n","name":"Integer Coercion Error","childOf":[681],"description":"Integer coercion refers to a set of flaws pertaining to the type casting, extension, or truncation of primitive data types. Several flaws fall under the category of integer coercion errors. For the most part, these errors in and of themselves result only in availability and data integrity issues. However, in some circumstances, they may result in other, more complicated security related flaws, such as buffer overflow conditions.","parentOf":[],"id":192,"memberOf":[189],"exampleCode":[" C\n   \n  \n  \n   \n    DataPacket *packet;\nint numHeaders;\nPacketHeader *headers;\n \nsock=AcceptSocketConnection();\nReadPacket(packet, sock);\nnumHeaders =packet->headers;\n \nif (numHeaders > 100) {\n    \n     ExitError(\"too many headers!\");\n    }\nheaders = malloc(numHeaders * sizeof(PacketHeader);\nParsePacketHeaders(packet, headers);\n   \n  \n \n"," C\n   \n  \n  \n   \n    int GetUntrustedInt () {\n    \n     return(0x0000FFFF);\n    }\n \nvoid main (int argc, char **argv) {\n    \n     \n      char path[256];\nchar *input;\nint i;\nshort s;\nunsigned int sz;\n \ni = GetUntrustedInt();\ns = i;\n\/* s is -1 so it passes the safety check - CWE-697 *\/ \nif (s > 256) {\n      \n       DiePainfully(\"go away!\\n\");\n      }\n \n\/* s is sign-extended and saved in sz *\/\nsz = s;\n \n\/* output"]},{"exampleDescription":"Example 1\nThis example, while not exploitable, shows the possible mangling of values associated with truncation errors:\nThe above code, when compiled and run on certain systems, returns the following output:\nThis problem may be exploitable when the truncated value is used as an array index, which can happen implicitly when 64-bit values are used as indexes, as they are truncated to 32 bits.\nExample 2\nIn the following Java example, the method updateSalesForProduct is part of a business application class that updates the sales information for a particular product. The method receives as arguments the product ID and the integer amount sold. The product ID is used to retrieve the total product count from an inventory object which returns the count as an integer. Before calling the method of the sales object to update the sales count the integer values are converted to The primitive type short since the method requires short type for the method arguments.\nHowever, a numeric truncation error can occur if the integer values are higher than the maximum value allowed for the primitive type short. This can cause unexpected results or loss or corruption of data. In this case the sales database may be corrupted with incorrect data. Explicit casting from a from a larger size primitive type to a smaller size primitive type should be prevented. The following example an if statement is added to validate that the integer values less than the maximum value for the primitive type short before the explicit cast and the call to the sales method.\n","name":"Numeric Truncation Error","childOf":[681,681,681],"description":"Truncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion. When a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.","parentOf":[],"id":197,"memberOf":[189],"exampleCode":[" C\n   \n  \n  \n   \n    int intPrimitive;\nshort shortPrimitive;\nintPrimitive = (int)(~((int)0) ^ (1 << (sizeof(int)*8-1)));\nshortPrimitive = intPrimitive;\nprintf(\"Int MAXINT"," Java\n   \n  \n  \n   \n    ...\n \/\/ update sales database for number of product sold with product ID \npublic void updateSalesForProduct(String productID, int amountSold) {\n    \n     \n \/\/ get the total number of products in inventory database \nint productCount = inventory.getProductCount(productID);\n \/\/ convert integer values to short, the method for the \n \n \/\/ sales object requires the parameters to be of type short \nshort count = (short) productCount;\nshort sold = (short) amountSold;\n \/\/ update sales database for product \nsales.updateSalesCount(productID, count, sold);\n     \n    }\n...\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following example, sensitive information might be printed depending on the exception that occurs.\nIf an exception related to SQL is handled by the catch, then the output might contain sensitive information such as SQL query structure or private information. If this output is redirected to a web user, this may represent a security problem.\nExample 2\nThis code tries to open a database connection, and prints any exceptions that occur.\nIf an exception occurs, the printed message exposes the location of the configuration file the script is using. An attacker can use this information to target the configuration file (perhaps exploiting a Path Traversal weakness). If the file can be read, the attacker could gain credentials for accessing the database. The attacker may also be able to replace the file with a malicious one, causing the application to use an arbitrary database.\nExample 3\nThe following code generates an error message that leaks the full pathname of the configuration file.\nIf this code is running on a server, such as a web application, then the person making the request should not know what the full pathname of the configuration directory is. By submitting a username that does not produce a $file that exists, an attacker could get this pathname. It could then be used to exploit path traversal or symbolic link following problems that may exist elsewhere in the application.\nExample 4\nIn the example below, the method getUserBankAccount retrieves a bank account object from a database using the supplied username and account number to query the database. If an SQLException is raised when querying the database, an error message is created and output to a log file.\nThe error message that is created includes information about the database query that may contain sensitive information about the database or query logic. In this case, the error message will expose the table name and column names used in the database. This data could be used to simplify other attacks, such as SQL injection (CWE-89) to directly access the database.\n","name":"Generation of Error Message Containing Sensitive Information","childOf":[755,200],"description":"The software generates an error message that includes sensitive information about its environment, users, or associated data. The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more serious attacks. The error message may be created in different ways: self-generated: the source code explicitly constructs the error message and delivers it externally-generated: the external environment, such as a language interpreter, handles the error and constructs its own message, whose contents are not under direct control by the programmer An attacker may use the contents of error messages to help launch another, more focused attack. For example, an attempt to exploit a path traversal weakness (CWE-22) might yield the full pathname of the installed application. In turn, this could be used to select the proper number of \"..\" sequences to navigate to the targeted file. An attack using SQL injection (CWE-89) might not initially succeed, but an error message could reveal the malformed query, which would expose query logic and possibly even passwords or other sensitive information used within the query.","parentOf":[],"id":209,"memberOf":[199,1015],"exampleCode":[" Java\n   \n  \n  \n   \n    try {\n    \n     \/...\/\n    }\ncatch (Exception e) {\n    \n     System.out.println(e);\n    }\n   \n  \n \n"," PHP\n   \n  \n  \n   \n    try {\n    \n     openDbConnection();\n    }\n \/\/print exception message that includes exception message and configuration file location \ncatch (Exception $e) {\n    \n     echo 'Caught exception"," Perl\n   \n  \n  \n   \n    $ConfigDir = \"\/home\/myprog\/config\";\n$uname = GetUserInput(\"username\");\n \n # avoid CWE-22, CWE-78, others.  \nExitError(\"Bad hacker!\") if ($uname !~ \/^\\w+$\/);\n$file = \"$ConfigDir\/$uname.txt\";\nif (! (-e $file)) {\n    \n     ExitError(\"Error"," Java\n   \n  \n  \n   \n    public BankAccount getUserBankAccount(String username, String accountNumber) {\n    \n     \n      BankAccount userAccount = null;\nString query = null;\ntry {\n      \n       if (isAuthorizedUser(username)) {\n       \n        query = \"SELECT * FROM accounts WHERE owner = \"\n+ username + \" AND accountID = \" + accountNumber;\nDatabaseManager dbManager = new DatabaseManager();\nConnection conn = dbManager.getConnection();\nStatement stmt = conn.createStatement();\nResultSet queryResult = stmt.executeQuery(query);\nuserAccount = (BankAccount)queryResult.getObject(accountNumber);\n       }\n      } catch (SQLException ex) {\n      \n       String logMessage = \"Unable to retrieve account information from database,\\nquery"]},{"exampleDescription":"Example 1\nIn the following example, the class DatabaseConnection opens and manages a connection to a database for a J2EE application. The method openDatabaseConnection opens a connection to the database using a DriverManager to create the Connection object conn to the database specified in the string constant CONNECT_STRING.\nThe use of the DriverManager class to directly manage the connection to the database violates the J2EE restriction against the direct management of connections. The J2EE application should use the web application container's resource management facilities to obtain a connection to the database as shown in the following example.\n","name":"J2EE Bad Practices: Direct Management of Connections","childOf":[695],"description":"The J2EE application directly manages connections, instead of using the container's connection management facilities. The J2EE standard forbids the direct management of connections. It requires that applications use the container's resource management facilities to obtain connections to resources. Every major web application container provides pooled database connection management as part of its resource management framework. Duplicating this functionality in an application is difficult and error prone, which is part of the reason it is forbidden under the J2EE standard.","parentOf":[],"id":245,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class DatabaseConnection {\n    \n     \n      private static final String CONNECT_STRING = \"jdbc"]},{"exampleDescription":"Example 1\nThe following example opens a socket to connect to a remote server.\nA Socket object is created directly within the Java servlet, which is a dangerous way to manage remote connections.\n","name":"J2EE Bad Practices: Direct Use of Sockets","childOf":[695],"description":"The J2EE application directly uses sockets instead of using framework method calls. The J2EE standard permits the use of sockets only for the purpose of communication with legacy systems when no higher-level protocol is available. Authoring your own communication protocol requires wrestling with difficult security issues. Without significant scrutiny by a security expert, chances are good that a custom communication protocol will suffer from security problems. Many of the same issues apply to a custom implementation of a standard protocol. While there are usually more resources available that address security concerns related to implementing a standard protocol, these resources are also available to attackers.","parentOf":[],"id":246,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \n     \n \/\/ Perform servlet tasks. \n...\n \n \/\/ Open a socket to a remote server (bad). \nSocket sock = null;\n \ntry {\n      \n       \n        sock = new Socket(remoteHostname, 3000);\n \n \/\/ Do something with the socket. \n...\n       \n      } catch (Exception e) {\n      \n       ...\n      }\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following example attempts to resolve a hostname.\nA DNS lookup failure will cause the Servlet to throw an exception.\nExample 2\nThe _alloca() function allocates memory on the stack. If an allocation request is too large for the available stack space, _alloca() throws an exception. If the exception is not caught, the program will crash, potentially enabling a denial of service attack. _alloca() has been deprecated as of Microsoft Visual Studio 2005(R). It has been replaced with the more secure _alloca_s().\nExample 3\nEnterCriticalSection() can raise an exception, potentially causing the program to crash. Under operating systems prior to Windows 2000, the EnterCriticalSection() function can raise an exception in low memory situations. If the exception is not caught, the program will crash, potentially enabling a denial of service attack.\n","name":"Uncaught Exception","childOf":[703,703,703],"description":"An exception is thrown from a function, but it is not caught. When an exception is not caught, it may cause the program to crash or expose sensitive information.","parentOf":[],"id":248,"memberOf":[389],"exampleCode":[" Java\n   \n  \n  \n   \n    protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {\n    \n     String ip = req.getRemoteAddr();\nInetAddress addr = InetAddress.getByName(ip);\n...\nout.println(\"hello \" + addr.getHostName());\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThis code could be used in an e-commerce application that supports transfers between accounts. It takes the total amount of the transfer, sends it to the new account, and deducts the amount from the original account.\nA race condition could occur between the calls to GetBalanceFromDatabase() and SendNewBalanceToDatabase().\nSuppose the balance is initially 100.00. An attack could be constructed as follows:\nAt this stage, the attacker should have a balance of 19.00 (due to 81.00 worth of transfers), but the balance is 99.00, as recorded in the database.\nTo prevent this weakness, the programmer has several options, including using a lock to prevent multiple simultaneous requests to the web application, or using a synchronization mechanism that includes all the code between GetBalanceFromDatabase() and SendNewBalanceToDatabase().\nExample 2\nThe following function attempts to acquire a lock in order to perform operations on a shared resource.\nHowever, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior.\nIn order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels.\nExample 3\nSuppose a processor's Memory Management Unit (MMU) has 5 other shadow MMUs to distribute its workload for its various cores. Each MMU has the start address and end address of \"accessible\" memory. Any time this accessible range changes (as per the processor's boot status), the main MMU sends an update message to all the shadow MMUs.\nSuppose the interconnect fabric does not prioritize such \"update\" packets over other general traffic packets. This introduces a race condition. If an attacker can flood the target with enough messages so that some of those attack packets reach the target before the new access ranges gets updated, then the attacker can leverage this scenario.\n","name":"Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')","childOf":[691],"description":"The program contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently. This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider. A race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc. A race condition violates these properties, which are closely related: Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution. Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence; when they are not, this violates atomicity. For example, the single \"x++\" statement may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read (the original value of x), followed by a computation (x+1), followed by a write (save the result to x). The interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the program; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable program.","parentOf":[367],"id":362,"memberOf":[],"exampleCode":[" Perl\n   \n  \n  \n   \n    $transfer_amount = GetTransferAmount();\n$balance = GetBalanceFromDatabase();\n \nif ($transfer_amount < 0) {\n    \n     FatalError(\"Bad Transfer Amount\");\n    }\n$newbalance = $balance - $transfer_amount;\nif (($balance - $transfer_amount) < 0) {\n    \n     FatalError(\"Insufficient Funds\");\n    }\nSendNewBalanceToDatabase($newbalance);\nNotifyUser(\"Transfer of $transfer_amount succeeded.\");\nNotifyUser(\"New balance"," C\n   \n  \n  \n   \n    void f(pthread_mutex_t *mutex) {\n    \n     \n      pthread_mutex_lock(mutex);\n \n \/* access shared resource *\/ \n \n \npthread_mutex_unlock(mutex);\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following example demonstrates the weakness.\n","name":"Race Condition within a Thread","childOf":[362,662,662],"description":"If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined. ","parentOf":[],"id":366,"memberOf":[557],"exampleCode":[" C\n   \n  \n  \n   \n    int foo = 0;\nint storenum(int num) {\n    \n     static int counter = 0;\ncounter++;\nif (num > foo) foo = num;\nreturn foo;\n    }\n   \n  \n \n"," Java\n   \n  \n  \n   \n    public classRace {\n    \n     \n      static int foo = 0;\npublic static void main() {\n      \n       \nnew Threader().start();\nfoo = 1;\n       \n      }\npublic static class Threader extends Thread {\n      \n       \npublic void run() {\n        \n         System.out.println(foo);\n        }\n       \n      }\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following example demonstrates the weakness.\nIn this example, bar and baz will be passed by reference to doOtherStuff() which may change them.\nExample 2\nIn the following Java example, the BookStore class manages the sale of books in a bookstore, this class includes the member objects for the bookstore inventory and sales database manager classes. The BookStore class includes a method for updating the sales database and inventory when a book is sold. This method retrieves a Book object from the bookstore inventory object using the supplied ISBN number for the book class, then calls a method for the sales object to update the sales information and then calls a method for the inventory object to update inventory for the BookStore.\nHowever, in this example the Book object that is retrieved and passed to the method of the sales object could have its contents modified by the method. This could cause unexpected results when the book object is sent to the method for the inventory object to update the inventory.\nIn the Java programming language arguments to methods are passed by value, however in the case of objects a reference to the object is passed by value to the method. When an object reference is passed as a method argument a copy of the object reference is made within the method and therefore both references point to the same object. This allows the contents of the object to be modified by the method that holds the copy of the object reference. [REF-374]\nIn this case the contents of the Book object could be modified by the method of the sales object prior to the call to update the inventory.\nTo prevent the contents of the Book object from being modified, a copy of the Book object should be made before the method call to the sales object. In the following example a copy of the Book object is made using the clone() method and the copy of the Book object is passed to the method of the sales object. This will prevent any changes being made to the original Book object.\n","name":"Passing Mutable Objects to an Untrusted Method","childOf":[668],"description":"The program sends non-cloned mutable data as an argument to a method or function. The function or method that has been called can alter or delete the mutable data. This could violate assumptions that the calling function has made about its state. In situations where unknown code is called with references to mutable data, this external code could make changes to the data sent. If this data was not previously cloned, the modified data might not be valid in the context of execution.","parentOf":[],"id":374,"memberOf":[371],"exampleCode":[" C\n   \n  \n  \n   \n    private"," Java\n   \n  \n  \n   \n    public class BookStore {\n    \n     \n      private BookStoreInventory inventory;\nprivate SalesDBManager sales;\n...\n \/\/ constructor for BookStore \npublic BookStore() {\n      \n       this.inventory = new BookStoreInventory();\nthis.sales = new SalesDBManager();\n...\n      }\npublic void updateSalesAndInventoryForBookSold(String bookISBN) {\n      \n       \n \/\/ Get book object from inventory using ISBN \nBook book = inventory.getBookWithISBN(bookISBN);\n \/\/ update sales information for book sold \nsales.updateSalesInformation(book);\n \/\/ update inventory \ninventory.updateInventory(book);\n       \n      }\n \/\/ other BookStore methods \n...\n     \n    }\npublic class Book {\n    \n     private String title;\nprivate String author;\nprivate String isbn;\n \/\/ Book object constructors and get\/set methods \n...\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThis class has a private list of patients, but provides a way to see the list :\nWhile this code only means to allow reading of the patient list, the getPatients() method returns a reference to the class's original patient list instead of a reference to a copy of the list. Any caller of this method can arbitrarily modify the contents of the patient list even though it is a private member of the class.\n","name":"Returning a Mutable Object to an Untrusted Caller","childOf":[668],"description":"Sending non-cloned mutable data as a return value may result in that data being altered or deleted by the calling function. In situations where functions return references to mutable data, it is possible that the external code which called the function may make changes to the data sent. If this data was not previously cloned, the class will then be using modified data which may violate assumptions about its internal state.","parentOf":[],"id":375,"memberOf":[371],"exampleCode":[" Java\n   \n  \n  \n   \n    public class ClinicalTrial {\n    \n     private PatientClass[] patientList = new PatientClass[50];\npublic getPatients(...){\n     \n      return patientList;\n     }\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIncluded in the doPost() method defined below is a call to System.exit() in the event of a specific exception.\n","name":"J2EE Bad Practices: Use of System.exit()","childOf":[705],"description":"A J2EE application uses System.exit(), which also shuts down its container. It is never a good idea for a web application to attempt to shut down the application container. Access to a function that can shut down the application is an avenue for Denial of Service (DoS) attacks.","parentOf":[],"id":382,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    Public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \n     try {\n     \n      ...\n     } catch (ApplicationSpecificException ase) {\n     \n      logger.error(\"Caught"]},{"exampleDescription":"Example 1\nIn the following example, a new Thread object is created and invoked directly from within the body of a doGet() method in a Java servlet.\n","name":"J2EE Bad Practices: Direct Use of Threads","childOf":[695],"description":"Thread management in a Web application is forbidden in some circumstances and is always highly error prone. Thread management in a web application is forbidden by the J2EE standard in some circumstances and is always highly error prone. Managing threads is difficult and is likely to interfere in unpredictable ways with the behavior of the application container. Even without interfering with the container, thread management usually leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other synchronization errors.","parentOf":[],"id":383,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \n     \n \/\/ Perform servlet tasks. \n...\n \n \/\/ Create a new thread to handle background processing. \nRunnable r = new Runnable() {\n      \n       \n        public void run() {\n        \n         \n \/\/ Process and store request statistics. \n...\n         \n        }\n       \n      };\n \nnew Thread(r).start();\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following code mistakenly catches a NullPointerException.\n","name":"Use of NullPointerException Catch to Detect NULL Pointer Dereference","childOf":[755],"description":"Catching NullPointerException should not be used as an alternative to programmatic checks to prevent dereferencing a null pointer. Programmers typically catch NullPointerException under three circumstances: The program contains a null pointer dereference. Catching the resulting exception was easier than fixing the underlying problem. The program explicitly throws a NullPointerException to signal an error condition. The code is part of a test harness that supplies unexpected input to the classes under test. Of these three circumstances, only the last is acceptable.","parentOf":[],"id":395,"memberOf":[389],"exampleCode":[" Java\n   \n  \n  \n   \n    try { \n    \n     mysteryMethod();\n     } catch (NullPointerException npe) {\n }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following code excerpt handles three types of exceptions in an identical fashion.\nAt first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:\nHowever, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.\n","name":"Declaration of Catch for Generic Exception","childOf":[221],"description":"Catching overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities. Multiple catch blocks can get ugly and repetitive, but \"condensing\" catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.","parentOf":[],"id":396,"memberOf":[389],"exampleCode":[]},{"exampleDescription":"Example 1\nThe following method throws three types of exceptions.\nWhile it might seem tidier to write\ndoing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.\nExample 2\nEarly versions of C++ (C++98, C++03, C++11) included a feature known as Dynamic Exception Specification. This allowed functions to declare what type of exceptions it may throw. It is possible to declare a general class of exception to cover any derived exceptions that may be throw.\nIn the example above, the code declares that myfunction() can throw an exception of type \"std::exception\" thus hiding details about the possible derived exceptions that could potentially be thrown.\n","name":"Declaration of Throws for Generic Exception","childOf":[221],"description":"Throwing overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities. Declaring a method to throw Exception or Throwable makes it difficult for callers to perform proper error handling and error recovery. Java's exception mechanism, for example, is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.","parentOf":[],"id":397,"memberOf":[389],"exampleCode":[]},{"exampleDescription":"Example 1\nThe following example demonstrates the weakness.\nIn this case, you may leave a thread locked accidentally.\n","name":"Improper Cleanup on Thrown Exception","childOf":[755],"description":"The product does not clean up its state or incorrectly cleans up its state when an exception is thrown, leading to unexpected state or control flow. Often, when functions or loops become complicated, some level of resource cleanup is needed throughout execution. Exceptions can disturb the flow of the code and prevent the necessary cleanup from happening.","parentOf":[],"id":460,"memberOf":[452,1012],"exampleCode":[" Java\n   \n  \n  \n   \n    public class foo {\n    \n     \n      public static final void main( String args[] ) {\n      \n       \nboolean returnValue;\nreturnValue=doStuff();\n       \n      }\npublic static final boolean doStuff( ) {\n      \n       \nboolean threadLock;\nboolean truthvalue=true;\ntry {\n        \n         \nwhile(\n \/\/check some condition \n) {\n          \n           \nthreadLock=true; \/\/do some stuff to truthvalue\nthreadLock=false;\n           \n          }\n         \n        }\ncatch (Exception e){\n        \n         \nSystem.err.println(\"You did something bad\");\nif (something) return truthvalue;\n         \n        }\nreturn truthvalue;\n       \n      }\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following code adds data to a list and then attempts to sort the data.\nSince basename is not necessarily unique, this may not sort how one would like it to be.\n","name":"Duplicate Key in Associative List (Alist)","childOf":[694],"description":"Duplicate keys in associative lists can lead to non-unique keys being mistaken for an error. A duplicate key entry -- if the alist is designed properly -- could be used as a constant time replace function. However, duplicate key entries could be inserted by mistake. Because of this ambiguity, duplicate key entries in an association list are not recommended and should not be allowed.","parentOf":[],"id":462,"memberOf":[137],"exampleCode":[" Python\n   \n  \n  \n   \n    alist = []\nwhile (foo())"]},{"exampleDescription":"Example 1\nA common reason that programmers use the reflection API is to implement their own command dispatcher. The following example shows a command dispatcher that does not use reflection:\nA programmer might refactor this code to use reflection as follows:\nThe refactoring initially appears to offer a number of advantages. There are fewer lines of code, the if\/else blocks have been entirely eliminated, and it is now possible to add new command types without modifying the command dispatcher. However, the refactoring allows an attacker to instantiate any object that implements the Worker interface. If the command dispatcher is still responsible for access control, then whenever programmers create a new class that implements the Worker interface, they must remember to modify the dispatcher's access control code. If they do not modify the access control code, then some Worker classes will not have any access control.\nOne way to address this access control problem is to make the Worker object responsible for performing the access control check. An example of the re-refactored code follows:\nAlthough this is an improvement, it encourages a decentralized approach to access control, which makes it easier for programmers to make access control mistakes. This code also highlights another security problem with using reflection to build a command dispatcher. An attacker can invoke the default constructor for any kind of object. In fact, the attacker is not even constrained to objects that implement the Worker interface; the default constructor for any object in the system can be invoked. If the object does not implement the Worker interface, a ClassCastException will be thrown before the assignment to ao, but if the constructor performs operations that work in the attacker's favor, the damage will already have been done. Although this scenario is relatively benign in simple applications, in larger applications where complexity grows exponentially it is not unreasonable that an attacker could find a constructor to leverage as part of an attack.\n","name":"Use of Externally","childOf":[610,913,20],"description":"The application uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code. If the application uses external inputs to determine which class to instantiate or which method to invoke, then an attacker could supply values to select unexpected classes or methods. If this occurs, then the attacker could create control flow paths that were not intended by the developer. These paths could bypass authentication or access control checks, or otherwise cause the application to behave in an unexpected manner. This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the application's classpath (CWE-427) or add new entries to the application's classpath (CWE-426). Under either of these conditions, the attacker can use reflection to introduce new, malicious behavior into the application.","parentOf":[],"id":470,"memberOf":[399],"exampleCode":[" Java\n   \n  \n  \n   \n    String ctl = request.getParameter(\"ctl\");\nClass cmdClass = Class.forName(ctl + \"Command\");\nWorker ao = (Worker) cmdClass.newInstance();\nao.doAction(request);\n   \n  \n \n"," Java\n   \n  \n  \n   \n    String ctl = request.getParameter(\"ctl\");\nClass cmdClass = Class.forName(ctl + \"Command\");\nWorker ao = (Worker) cmdClass.newInstance();\nao.checkAccessControl(request);\nao.doAction(request);\n   \n  \n \n"]},{"exampleDescription":"Example 1\nWhile there are no complete fixes aside from conscientious programming, the following steps will go a long way to ensure that NULL pointer dereferences do not occur.\nIf you are working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the if statement; and unlock when it has finished.\nExample 2\nThis example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.\nIf an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to strcpy().\nNote that this code is also vulnerable to a buffer overflow (CWE-119).\nExample 3\nIn the following code, the programmer assumes that the system always has a property named \"cmd\" defined. If an attacker can control the program's environment so that \"cmd\" is not defined, the program throws a NULL pointer exception when it attempts to call the trim() method.\nExample 4\nThis Android application has registered to handle a URL when sent an intent:\nThe application assumes the URL will always be included in the intent. When the URL is not present, the call to getStringExtra() will return null, thus causing a null pointer exception when length() is called.\n","name":"NULL Pointer Dereference","childOf":[754,754],"description":"A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit. NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.","parentOf":[],"id":476,"memberOf":[465],"exampleCode":[" C\n   \n  \n  \n   \n    void host_lookup(char *user_supplied_addr){\n    \n     \n      struct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n \n \/*routine that ensures user_supplied_addr is in the right format for conversion *\/ \n \nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n     \n    }\n   \n  \n \n"," Java\n   \n  \n  \n   \n    String cmd = System.getProperty(\"cmd\");\ncmd = cmd.trim();\n   \n  \n \n"," Java\n   \n  \n  \n   \n ... \nIntentFilter filter = new IntentFilter(\"com.example.URLHandler.openURL\");\nMyReceiver receiver = new MyReceiver();\nregisterReceiver(receiver, filter);\n ... \n \npublic class UrlHandlerReceiver extends BroadcastReceiver {\n    \n     \n      @Override\npublic void onReceive(Context context, Intent intent) {\n      \n       \n        if(\"com.example.URLHandler.openURL\".equals(intent.getAction())) {\n        \n         String URL = intent.getStringExtra(\"URLToOpen\");\nint length = URL.length();\n         \n ... \n}\n       \n      }\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following does not properly check the return code in the case where the security_check function returns a -1 value when an error occurs. If an attacker can supply data that will invoke an error, the attacker can bypass the security check:\nInstead a default label should be used for unaccounted conditions:\nThis label is used because the assumption cannot be made that all possible cases are accounted for. A good practice is to reserve the default case for error handling.\nExample 2\nIn the following Java example the method getInterestRate retrieves the interest rate for the number of points for a mortgage. The number of points is provided within the input parameter and a switch statement will set the interest rate value to be returned based on the number of points.\nHowever, this code assumes that the value of the points input parameter will always be 0, 1 or 2 and does not check for other incorrect values passed to the method. This can be easily accomplished by providing a default label in the switch statement that outputs an error message indicating an invalid value for the points input parameter and returning a null value.\nExample 3\nIn the following Python example the match-case statements (available in Python version 3.10 and later) perform actions based on the result of the process_data() function. The expected return is either 0 or 1. However, if an unexpected result (e.g., -1 or 2) is obtained then no actions will be taken potentially leading to an unexpected program state.\nThe recommended approach is to add a default case that captures any unexpected result conditions, regardless of how improbable these unexpected conditions might be, and properly handles them.\nExample 4\nIn the following JavaScript example the switch-case statements (available in JavaScript version 1.2 and later) are used to process a given step based on the result of a calcuation involving two inputs. The expected return is either 1, 2, or 3. However, if an unexpected result (e.g., 4) is obtained then no action will be taken potentially leading to an unexpected program state.\nThe recommended approach is to add a default case that captures any unexpected result conditions and properly handles them.\nExample 5\nThe Finite State Machine (FSM) shown in the \"bad\" code snippet below assigns the output (\"out\") based on the value of state, which is determined based on the user provided input (\"user_input\").\n\nThe case statement does not include a default to handle the scenario when the user provides inputs of 3'h6 and 3'h7. Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome.\nAdding a default statement to handle undefined inputs mitigates this issue. This is shown in the \"Good\" code snippet below. The default statement is in bold.\n\n","name":"Missing Default Case in Multiple Condition Expression","childOf":[1023],"description":"The code does not have a default case in an expression with multiple conditions, such as a switch statement. If a multiple-condition expression (such as a switch in C) omits the default case but does not consider or handle all possible values that could occur, then this might lead to complex logical errors and resultant weaknesses. Because of this, further decisions are made based on poor information, and cascading failure results. This cascading failure may result in any number of security issues, and constitutes a significant failure in the system.","parentOf":[],"id":478,"memberOf":[1006],"exampleCode":[" C\n   \n  \n  \n   \n    #define FAILED 0\n#define PASSED 1\nint result;\n...\nresult = security_check(data);\nswitch (result) {\n    \n     \n      case FAILED"," Java\n   \n  \n  \n   \n    public static final String INTEREST_RATE_AT_ZERO_POINTS = \"5.00\";\npublic static final String INTEREST_RATE_AT_ONE_POINTS = \"4.75\";\npublic static final String INTEREST_RATE_AT_TWO_POINTS = \"4.50\";\n...\npublic BigDecimal getInterestRate(int points) {\n    \n     \n      BigDecimal result = new BigDecimal(INTEREST_RATE_AT_ZERO_POINTS);\n \nswitch (points) {\n      \n       \n        case 0"," Python\n   \n  \n  \n   \n    result = process_data(data) \nmatch result"," JavaScript\n   \n  \n  \n   \n    let step = input1 + input2; \nswitch(step) { \n    \n     case 1"," Verilog\n   \n  \n  \n   \n    module fsm_1(out, user_input, clk, rst_n); \ninput [2"]},{"exampleDescription":"Example 1\nThe following C\/C++ and C# examples attempt to validate an int input parameter against the integer value 100.\nHowever, the expression to be evaluated in the if statement uses the assignment operator \"=\" rather than the comparison operator \"==\". The result of using the assignment operator instead of the comparison operator causes the int variable to be reassigned locally and the expression in the if statement will always evaluate to the value on the right hand side of the expression. This will result in the input value not being properly validated, which can cause unexpected results.\nExample 2\nIn this example, we show how assigning instead of comparing can impact code when values are being passed by reference instead of by value. Consider a scenario in which a string is being processed from user input. Assume the string has already been formatted such that different user inputs are concatenated with the colon character. When the processString function is called, the test for the colon character will result in an insertion of the colon character instead, adding new input separators. Since the string was passed by reference, the data sentinels will be inserted in the original string (CWE-464), and further processing of the inputs will be altered, possibly malformed..\nExample 3\nThe following Java example attempts to perform some processing based on the boolean value of the input parameter. However, the expression to be evaluated in the if statement uses the assignment operator \"=\" rather than the comparison operator \"==\". As with the previous examples, the variable will be reassigned locally and the expression in the if statement will evaluate to true and unintended processing may occur.\nWhile most Java compilers will catch the use of an assignment operator when a comparison operator is required, for boolean variables in Java the use of the assignment operator within an expression is allowed. If possible, try to avoid using comparison operators on boolean variables in java. Instead, let the values of the variables stand for themselves, as in the following code.\nAlternatively, to test for false, just use the boolean NOT operator.\nExample 4\nThe following example demonstrates the weakness.\n","name":"Assigning instead of Comparing","childOf":[480],"description":"The code uses an operator for assignment when the intention was to perform a comparison. In many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the right-hand side of the predicate.","parentOf":[],"id":481,"memberOf":[],"exampleCode":[" C\n   \n  \n  \n   \n    int isValid(int value) {\n    \n     if (value=100) {\n     \n      printf(\"Value is valid\\n\");\nreturn(1);\n     }\nprintf(\"Value is not valid\\n\");\nreturn(0);\n    }\n   \n  \n \n"," C#\n   \n  \n  \n   \n    bool isValid(int value) {\n    \n     if (value=100) {\n     \n      Console.WriteLine(\"Value is valid.\");\nreturn true;\n     }\nConsole.WriteLine(\"Value is not valid.\");\nreturn false;\n    }\n   \n  \n \n"," C\n   \n  \n  \n   \n    void processString (char *str) {\n    \n     \n      int i;\n \nfor(i=0; i<strlen(str); i++) {\n      \n       if (isalnum(str[i])){\n       \n        processChar(str[i]);\n       }\nelse if (str[i] = '"," Java\n   \n  \n  \n   \n    public void checkValid(boolean isValid) {\n    \n     if (isValid = true) {\n     \n      System.out.println(\"Performing processing\");\ndoSomethingImportant();\n     }\nelse {\n     \n      System.out.println(\"Not Valid, do not perform processing\");\nreturn;\n     }\n    }\n   \n  \n \n"," C\n   \n  \n  \n   \n    void called(int foo){\n    \n     if (foo=1) printf(\"foo\\n\");\n    }\nint main() {\n    \n     \ncalled(2);\nreturn 0;\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn both of these examples, a message is printed based on the month passed into the function:\nBoth examples do not use a break statement after each case, which leads to unintended fall-through behavior. For example, calling \"printMessage(10)\" will result in the text \"OctoberNovemberDecember is a great month\" being printed.\n","name":"Omitted Break Statement in Switch","childOf":[670],"description":"The program omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition. This can lead to critical code executing in situations where it should not.","parentOf":[],"id":484,"memberOf":[438],"exampleCode":[" Java\n   \n  \n  \n   \n    public void printMessage(int month){\n    \n     \n      switch (month) {\n      \n       \ncase 1"," C\n   \n  \n  \n   \n    void printMessage(int month){\n    \n     \n      switch (month) {\n      \n       \ncase 1"]},{"exampleDescription":"Example 1\nIn this example, the expression in the if statement compares the class of the inputClass object to a trusted class by comparing the class names.\nHowever, multiple classes can have the same name therefore comparing an object's class by name can allow untrusted classes of the same name as the trusted class to be use to execute unintended or incorrect code. To compare the class of an object to the intended class the getClass() method and the comparison operator \"==\" should be used to ensure the correct trusted class is used, as shown in the following example.\nExample 2\nIn this example, the Java class, TrustedClass, overrides the equals method of the parent class Object to determine equivalence of objects of the class. The overridden equals method first determines if the object, obj, is the same class as the TrustedClass object and then compares the object's fields to determine if the objects are equivalent.\nHowever, the equals method compares the class names of the object, obj, and the TrustedClass object to determine if they are the same class. As with the previous example using the name of the class to compare the class of objects can lead to the execution of unintended or incorrect code if the object passed to the equals method is of another class with the same name. To compare the class of an object to the intended class, the getClass() method and the comparison operator \"==\" should be used to ensure the correct trusted class is used, as shown in the following example.\n","name":"Comparison of Classes by Name","childOf":[1025],"description":"The program compares classes by name, which can cause it to use the wrong class when multiple classes can have the same name. If the decision to trust the methods and data of an object is based on the name of a class, it is possible for malicious users to send objects of the same name as trusted classes and thereby gain the trust afforded to known classes and types.","parentOf":[],"id":486,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    if (inputClass.getClass().getName().equals(\"TrustedClassName\")) {\n    \n     \n \/\/ Do something assuming you trust inputClass \n \n \/\/ ... \n\n     \n    }\n   \n  \n \n"," Java\n   \n  \n  \n   \n    public class TrustedClass {\n    \n     \n      ...\n \n@Override\npublic boolean equals(Object obj) {\n      \n       \n        boolean isEquals = false;\n \n \/\/ first check to see if the object is of the same class \nif (obj.getClass().getName().equals(this.getClass().getName())) {\n        \n         \n \/\/ then compare object fields \n...\nif (...) {\n          \n           isEquals = true;\n          }\n         \n        }\n \nreturn isEquals;\n       \n      }\n \n...\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following example demonstrates the weakness.\n","name":"Reliance on Package","childOf":[664],"description":"Java packages are not inherently closed; therefore, relying on them for code security is not a good practice. The purpose of package scope is to prevent accidental access by other parts of a program. This is an ease-of-software-development feature but not a security feature.","parentOf":[],"id":487,"memberOf":[1006],"exampleCode":[" Java\n   \n  \n  \n   \n    package math;\npublic class Lebesgue implements Integration{\n    \n     \n      public final Static String youAreHidingThisFunction(functionToIntegrate){\n      \n       \nreturn ...;\n       \n      }\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn this example, a public class \"BankAccount\" implements the cloneable() method which declares \"Object clone(string accountnumber)\":\nExample 2\nIn the example below, a clone() method is defined without being declared final.\n","name":"Public cloneable() Method Without Final ('Object Hijack')","childOf":[668],"description":"A class has a cloneable() method that is not declared final, which allows an object to be created without calling the constructor. This can cause the object to be in an unexpected state. ","parentOf":[],"id":491,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class BankAccount implements Cloneable{\n    \n     \n      public Object clone(String accountnumber) throws\nCloneNotSupportedException\n{\n      \n       \n        Object returnMe = new BankAccount(account number);\n...\n\n       \n      }\n     \n    }\n   \n  \n \n"," Java\n   \n  \n  \n   \n    protected Object clone() throws CloneNotSupportedException {\n    \n     ...\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following Java Applet code mistakenly makes use of an inner class.\nExample 2\nThe following example shows a basic use of inner classes. The class OuterClass contains the private member inner class InnerClass. The private inner class InnerClass includes the method concat that accesses the private member variables of the class OuterClass to output the value of one of the private member variables of the class OuterClass and returns a string that is a concatenation of one of the private member variables of the class OuterClass, the separator input parameter of the method and the private member variable of the class InnerClass.\nAlthough this is an acceptable use of inner classes it demonstrates one of the weaknesses of inner classes that inner classes have complete access to all member variables and methods of the enclosing class even those that are declared private and protected. When inner classes are compiled and translated into Java bytecode the JVM treats the inner class as a peer class with package level access to the enclosing class.\nTo avoid this weakness of inner classes, consider using either static inner classes, local inner classes, or anonymous inner classes.\nThe following Java example demonstrates the use of static inner classes using the previous example. The inner class InnerClass is declared using the static modifier that signifies that InnerClass is a static member of the enclosing class OuterClass. By declaring an inner class as a static member of the enclosing class, the inner class can only access other static members and methods of the enclosing class and prevents the inner class from accessing nonstatic member variables and methods of the enclosing class. In this case the inner class InnerClass can only access the static member variable memberTwo of the enclosing class OuterClass but cannot access the nonstatic member variable memberOne.\nThe only limitation with using a static inner class is that as a static member of the enclosing class the inner class does not have a reference to instances of the enclosing class. For many situations this may not be ideal. An alternative is to use a local inner class or an anonymous inner class as shown in the next examples.\nExample 3\nIn the following example the BankAccount class contains the private member inner class InterestAdder that adds interest to the bank account balance. The start method of the BankAccount class creates an object of the inner class InterestAdder, the InterestAdder inner class implements the ActionListener interface with the method actionPerformed. A Timer object created within the start method of the BankAccount class invokes the actionPerformed method of the InterestAdder class every 30 days to add the interest to the bank account balance based on the interest rate passed to the start method as an input parameter. The inner class InterestAdder needs access to the private member variable balance of the BankAccount class in order to add the interest to the bank account balance.\nHowever as demonstrated in the previous example, because InterestAdder is a non-static member inner class of the BankAccount class, InterestAdder also has access to the private member variables of the BankAccount class - including the sensitive data contained in the private member variables for the bank account owner's name, Social Security number, and the bank account number.\nIn the following example the InterestAdder class from the above example is declared locally within the start method of the BankAccount class. As a local inner class InterestAdder has its scope restricted to the method (or enclosing block) where it is declared, in this case only the start method has access to the inner class InterestAdder, no other classes including the enclosing class has knowledge of the inner class outside of the start method. This allows the inner class to access private member variables of the enclosing class but only within the scope of the enclosing method or block.\nA similar approach would be to use an anonymous inner class as demonstrated in the next example. An anonymous inner class is declared without a name and creates only a single instance of the inner class object. As in the previous example the anonymous inner class has its scope restricted to the start method of the BankAccount class.\nExample 4\nIn the following Java example a simple applet provides the capability for a user to input a URL into a text field and have the URL opened in a new browser window. The applet contains an inner class that is an action listener for the submit button, when the user clicks the submit button the inner class action listener's actionPerformed method will open the URL entered into the text field in a new browser window. As with the previous examples using inner classes in this manner creates a security risk by exposing private variables and methods. Inner classes create an additional security risk with applets as applets are executed on a remote machine through a web browser within the same JVM and therefore may run side-by-side with other potentially malicious code.\nAs with the previous examples a solution to this problem would be to use a static inner class, a local inner class or an anonymous inner class. An alternative solution would be to have the applet implement the action listener rather than using it as an inner class as shown in the following example.\n","name":"Use of Inner Class Containing Sensitive Data","childOf":[668],"description":"Inner classes are translated into classes that are accessible at package scope and may expose code that the programmer intended to keep private to attackers. Inner classes quietly introduce several security concerns because of the way they are translated into Java bytecode. In Java source code, it appears that an inner class can be declared to be accessible only by the enclosing class, but Java bytecode has no concept of an inner class, so the compiler must transform an inner class declaration into a peer class with package level access to the original outer class. More insidiously, since an inner class can access private fields in its enclosing class, once an inner class becomes a peer class in bytecode, the compiler converts private fields accessed by the inner class into protected fields.","parentOf":[],"id":492,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public final class urlTool extends Applet {\n    \n     private final class urlHelper {\n     \n      ...\n     }\n...\n    }\n   \n  \n \n"," Java\n   \n  \n  \n   \n    public class OuterClass {\n    \/\/ private member variables of OuterClass \nprivate String memberOne;\nprivate String memberTwo;\n \n \/\/ constructor of OuterClass \npublic OuterClass(String varOne, String varTwo) {\n     \n      this.memberOne = varOne;\nthis.memberTwo = varTwo;\n     }\n \n \/\/ InnerClass is a member inner class of OuterClass \nprivate class InnerClass {\n     \n      private String innerMemberOne;\n \npublic InnerClass(String innerVarOne) {\n      \n       this.innerMemberOne = innerVarOne;\n      }\n \npublic String concat(String separator) {\n      \/\/ InnerClass has access to private member variables of OuterClass \nSystem.out.println(\"Value of memberOne is"," Java\n   \n  \n  \n   \n    public class BankAccount {\n    \n     \n \/\/ private member variables of BankAccount class \nprivate String accountOwnerName;\nprivate String accountOwnerSSN;\nprivate int accountNumber;\nprivate double balance;\n \n \/\/ constructor for BankAccount class \npublic BankAccount(String accountOwnerName, String accountOwnerSSN,\nint accountNumber, double initialBalance, int initialRate)\n{\n      \n       this.accountOwnerName = accountOwnerName;\nthis.accountOwnerSSN = accountOwnerSSN;\nthis.accountNumber = accountNumber;\nthis.balance = initialBalance;\nthis.start(initialRate);\n      }\n \n \/\/ start method will add interest to balance every 30 days \n \n \/\/ creates timer object and interest adding action listener object \npublic void start(double rate)\n{\n      \n       ActionListener adder = new InterestAdder(rate);\nTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\nt.start();\n      }\n \n \/\/ InterestAdder is an inner class of BankAccount class \n \n \/\/ that implements the ActionListener interface \nprivate class InterestAdder implements ActionListener\n{\n      \n       \n        private double rate;\n \npublic InterestAdder(double aRate)\n{\n        \n         this.rate = aRate;\n        }\n \npublic void actionPerformed(ActionEvent event)\n{\n        \n         \/\/ update interest \ndouble interest = BankAccount.this.balance * rate \/ 100;\nBankAccount.this.balance += interest;\n         \n        }\n\n       \n      }\n     \n    }\n   \n  \n \n"," \");\nenterUrlTextField = new TextField(\"\", 20);\nsubmitButton = new Button(\"Submit\");\nadd(enterUrlLabel);\nadd(enterUrlTextField);\nadd(submitButton);\nActionListener submitButtonListener = new SubmitButtonListener();\nsubmitButton.addActionListener(submitButtonListener);\n      }\n \n \/\/ button listener inner class for UrlToolApplet class \nprivate class SubmitButtonListener implements ActionListener {\n      \n       \n        public void actionPerformed(ActionEvent evt) {\n        \n         \n          if (evt.getSource() == submitButton) {\n          \n           String urlString = enterUrlTextField.getText();\nURL url = null;\ntry {\n           \n            url = new URL(urlString);\n           } catch (MalformedURLException e) {\n           \n            System.err.println(\"Malformed URL"]},{"exampleDescription":"Example 1\nSuppose this WidgetData class is used for an e-commerce web site. The programmer attempts to prevent price-tampering attacks by setting the price of the widget using the constructor.\nThe price field is not final. Even though the value is set by the constructor, it could be modified by anybody that has access to an instance of WidgetData.\nExample 2\nAssume the following code is intended to provide the location of a configuration file that controls execution of the application.\nWhile this field is readable from any function, and thus might allow an information leak of a pathname, a more serious problem is that it can be changed by any function.\n","name":"Critical Public Variable Without Final Modifier","childOf":[668],"description":"The product has a critical public variable that is not final, which allows the variable to be modified to contain unexpected values. If a field is non-final and public, it can be changed once the value is set by any function that has access to the class which contains the field. This could lead to a vulnerability if other parts of the program make assumptions about the contents of that field.","parentOf":[],"id":493,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public final class WidgetData extends Applet {\n    \n     public float price;\n...\npublic WidgetData(...) {\n     \n      this.price = LookupPrice(\"MyWidgetType\");\n     }\n    }\n   \n  \n \n"," C++\n   \n  \n  \n   \n    public string configPath = \"\/etc\/application\/config.dat\";\n   \n  \n \n"," Java\n   \n  \n  \n   \n    public String configPath = new String(\"\/etc\/application\/config.dat\");\n   \n  \n \n"]},{"exampleDescription":"Example 1\nHere, a public method in a Java class returns a reference to a private array. Given that arrays in Java are mutable, any modifications made to the returned reference would be reflected in the original private array.\nExample 2\nIn this example, the Color class defines functions that return non-const references to private members (an array type and an integer type), which are then arbitrarily altered from outside the control of the class.\n","name":"Private Data Structure Returned From A Public Method","childOf":[664],"description":"The product has a method that is declared public, but returns a reference to a private data structure, which could then be modified in unexpected ways. ","parentOf":[],"id":495,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    private String[] colors;\npublic String[] getColors() {\n    \n     return colors;\n    }\n   \n  \n \n"," C++\n   \n  \n  \n   \n    class Color\n{\n    \n     private"]},{"exampleDescription":"Example 1\nIn the example below, the setRoles() method assigns a publically-controllable array to a private field, thus allowing the caller to modify the private array directly by virtue of the fact that arrays in Java are mutable.\n","name":"Public Data Assigned to Private Array","childOf":[664],"description":"Assigning public data to a private array is equivalent to giving public access to the array. ","parentOf":[],"id":496,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    private String[] userRoles;\npublic void setUserRoles(String[] userRoles) {\n    \n     this.userRoles = userRoles;\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following example demonstrates the weakness.\nMake classes uncloneable by defining a clone function like:\n","name":"Cloneable Class Containing Sensitive Information","childOf":[668],"description":"The code contains a class with sensitive data, but the class is cloneable. The data can then be accessed by cloning the class. Cloneable classes are effectively open classes, since data cannot be hidden in them. Classes that do not explicitly deny cloning can be cloned by any other class without running the constructor.","parentOf":[],"id":498,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class CloneClient {\n    \n     \n      public CloneClient() \/\/throws\njava.lang.CloneNotSupportedException {\n      \n       \nTeacher t1 = new Teacher(\"guddu\",\"22,nagar road\");\n\/\/...\n\/\/ Do some stuff to remove the teacher.\nTeacher t2 = (Teacher)t1.clone();\nSystem.out.println(t2.name);\n       \n      }\npublic static void main(String args[]) {\n      \n       \nnew CloneClient();\n       \n      }\n     \n    }\nclass Teacher implements Cloneable {\n    \n     \npublic Object clone() {\n      \n       \ntry {\n        \n         return super.clone();\n        }\ncatch (java.lang.CloneNotSupportedException e) {\n        \n         \nthrow new RuntimeException(e.toString());\n         \n        }\n       \n      }\npublic String name;\npublic String clas;\npublic Teacher(String name,String clas) {\n      \n       \nthis.name = name;\nthis.clas = clas;\n       \n      }\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThis code creates a new record for a medical patient:\nThis object does not explicitly deny serialization, allowing an attacker to serialize an instance of this object and gain a patient's name and Social Security number even though those fields are private.\n","name":"Serializable Class Containing Sensitive Data","childOf":[668],"description":"The code contains a class with sensitive data, but the class does not explicitly deny serialization. The data can be accessed by serializing the class through another class. Serializable classes are effectively open classes since data cannot be hidden in them. Classes that do not explicitly deny serialization can be serialized by any other class, which can then in turn use the data stored inside it.","parentOf":[],"id":499,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    class PatientRecord {\n    \n     private String name;\nprivate String socialSecurityNum;\npublic Patient(String name,String ssn) {\n     \n      this.SetName(name);\nthis.SetSocialSecurityNumber(ssn);\n     }\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following examples use of a public static String variable to contain the name of a property\/configuration file for the application.\nHaving a public static variable that is not marked final (constant) may allow the variable to the altered in a way not intended by the application. In this example the String variable can be modified to indicate a different on nonexistent properties file which could cause the application to crash or caused unexpected behavior.\n","name":"Public Static Field Not Marked Final","childOf":[493],"description":"An object contains a public static field that is not marked final, which might allow it to be modified in unexpected ways. Public static variables can be read without an accessor and changed without a mutator by any classes in the application.","parentOf":[],"id":500,"memberOf":[],"exampleCode":[" C++\n   \n  \n  \n   \n    class SomeAppClass {\n    \n     \npublic"," Java\n   \n  \n  \n   \n    public class SomeAppClass {\n    \n     \npublic static String appPropertiesFile = \"app\/Application.properties\";\n...\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThis code snippet deserializes an object from a file and uses it as a UI button:\nThis code does not attempt to verify the source or contents of the file before deserializing it. An attacker may be able to replace the intended file with a file that contains arbitrary malicious code which will be executed when the button is pressed.\nTo mitigate this, explicitly define final readObject() to prevent deserialization. An example of this is:\nExample 2\nIn Python, the Pickle library handles the serialization and deserialization processes. In this example derived from [REF-467], the code receives and parses data, and afterwards tries to authenticate a user based on validating a token.\nUnfortunately, the code does not verify that the incoming data is legitimate. An attacker can construct a illegitimate, serialized object \"AuthToken\" that instantiates one of Python's subprocesses to execute arbitrary commands. For instance,the attacker could construct a pickle that leverages Python's subprocess module, which spawns new processes and includes a number of arguments for various uses. Since Pickle allows objects to define the process for how they should be unpickled, the attacker can direct the unpickle process to call Popen in the subprocess module and execute \/bin\/sh.\n","name":"Deserialization of Untrusted Data","childOf":[913,913],"description":"The application deserializes untrusted data without sufficiently verifying that the resulting data will be valid. It is often convenient to serialize objects for communication or to save them for later use. However, deserialized data or code can often be modified without using the provided accessor functions if it does not use cryptography to protect itself. Furthermore, any cryptography would still be client-side security -- which is a dangerous security assumption. Data that is untrusted can not be trusted to be well-formed. When developers place no restrictions on \"gadget chains,\" or series of instances and method invocations that can self-execute during the deserialization process (i.e., before the object is returned to the caller), it is sometimes possible for attackers to leverage them to perform unauthorized actions, like generating a shell.","parentOf":[],"id":502,"memberOf":[399,1019],"exampleCode":[" Java\n   \n  \n  \n   \n    try {\n    \n     File file = new File(\"object.obj\");\nObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\njavax.swing.JButton button = (javax.swing.JButton) in.readObject();\nin.close();\n    }\n   \n  \n \n"," Python\n   \n  \n  \n   \n    try {\n    \n     \n      class ExampleProtocol(protocol.Protocol)"]},{"exampleDescription":"Example 1\nIn the following Java example the class InputFileRead enables an input file to be read using a FileReader object. In the constructor of this class a default input file path is set to some directory on the local file system and the method setInputFile must be called to set the name of the input file to be read in the default directory. The method readInputFile will create the FileReader object and will read the contents of the file. If the method setInputFile is not called prior to calling the method readInputFile then the File object will remain null when initializing the FileReader object. A Java RuntimeException will be raised, and an error message will be output to the user.\nHowever, the error message output to the user contains information regarding the default directory on the local file system. This information can be exploited and may lead to unauthorized access or use of the system. Any Java RuntimeExceptions that are handled should not expose sensitive information to the user.\nExample 2\nIn the example below, the BankManagerLoginServlet servlet class will process a login request to determine if a user is authorized to use the BankManager Web service. The doPost method will retrieve the username and password from the servlet request and will determine if the user is authorized. If the user is authorized the servlet will go to the successful login page. Otherwise, the servlet will raise a FailedLoginException and output the failed login message to the error page of the service.\nHowever, the output message generated by the FailedLoginException includes the user-supplied password. Even if the password is erroneous, it is probably close to the correct password. Since it is printed to the user's page, anybody who can see the screen display will be able to see the password. Also, if the page is cached, the password might be written to disk.\n","name":"Java Runtime Error Message Containing Sensitive Information","childOf":[211],"description":"In many cases, an attacker can leverage the conditions that cause unhandled exception errors in order to gain unauthorized access to the system. ","parentOf":[],"id":537,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class InputFileRead {\n\n    \n     \n      private File readFile = null;\nprivate FileReader reader = null;\nprivate String inputFilePath = null;\nprivate final String DEFAULT_FILE_PATH = \"c"," Java\n   \n  \n  \n   \n    public class BankManagerLoginServlet extends HttpServlet {\n    \n     \n      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n      \n       \n        try {\n        \n         \n \/\/ Get username and password from login page request \nString username = request.getParameter(\"username\");\nString password = request.getParameter(\"password\");\n \/\/ Authenticate user \nBankManager bankMgr = new BankManager();\nboolean isAuthentic = bankMgr.authenticateUser(username, password);\n \/\/ If user is authenticated then go to successful login page \nif (isAuthentic) {\n          \n           request.setAttribute(\"login\", new String(\"Login Successful.\"));\ngetServletContext().getRequestDispatcher(\"\/BankManagerServiceLoggedIn.jsp\"). forward(request, response);\n          }\nelse {\n          \n           \n \/\/ Otherwise, raise failed login exception and output unsuccessful login message to error page \nthrow new FailedLoginException(\"Failed Login for user \" + username + \" with password \" + password);\n           \n          }\n         \n        } catch (FailedLoginException ex) {\n        \n         \n \/\/ output failed login message to error page \nrequest.setAttribute(\"error\", new String(\"Login Error\"));\nrequest.setAttribute(\"message\", ex.getMessage());\ngetServletContext().getRequestDispatcher(\"\/ErrorPage.jsp\").forward(request, response);\n         \n        }\n       \n      }\n     \n    \n   \n  \n \n"]},{"exampleDescription":"Example 1\nThis method is part of a singleton pattern, yet the following singleton() pattern is not thread-safe. It is possible that the method will create two objects instead of only one.\nConsider the following course of events:\n\n\nAt this point, the threads have created and returned two different objects.\n","name":"Use of Singleton Pattern Without Synchronization in a Multithreaded Context","childOf":[820,662,662],"description":"The software uses the singleton pattern when creating a resource within a multithreaded environment. The use of a singleton pattern may not be thread-safe.","parentOf":[],"id":543,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    private static NumberConverter singleton;\npublic static NumberConverter get_singleton() {\n    \n     if (singleton == null) {\n     \n      singleton = new NumberConverter();\n     }\nreturn singleton;\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following code implements a basic counter for how many times the page has been accesed.\nConsider when two separate threads, Thread A and Thread B, concurrently handle two different requests:\n\n\nAt this point, both Thread A and Thread B print that one hit has been seen, even though two separate requests have been processed. The value of count should be 2, not 1.\nWhile this example does not have any real serious implications, if the shared variable in question is used for resource tracking, then resource consumption could occur. Other scenarios exist.\n","name":"Unsynchronized Access to Shared Data in a Multithreaded Context","childOf":[820,662,662],"description":"The product does not properly synchronize shared data, such as static variables across threads, which can lead to undefined behavior and unpredictable data changes. Within servlets, shared static variables are not protected from concurrent access, but servlets are multithreaded. This is a typical programming mistake in J2EE applications, since the multithreading is handled by the framework. When a shared variable can be influenced by an attacker, one thread could wind up modifying the variable to contain data that is not valid for a different thread that is also using the data within the variable. Note that this weakness is not unique to servlets.","parentOf":[],"id":567,"memberOf":[557],"exampleCode":[" Java\n   \n  \n  \n   \n    public static class Counter extends HttpServlet {\n    \n     static int count = 0;\nprotected void doGet(HttpServletRequest in, HttpServletResponse out)\nthrows ServletException, IOException {\n     \n      out.setContentType(\"text\/plain\");\nPrintWriter p = out.getWriter();\ncount++;\np.println(count + \" hits so far!\");\n     }\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following method omits the call to super.finalize().\n","name":"finalize() Method Without super.finalize()","childOf":[573],"description":"The software contains a finalize() method that does not call super.finalize(). The Java Language Specification states that it is a good practice for a finalize() method to call super.finalize().","parentOf":[],"id":568,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    protected void finalize() {\n    \n     discardNative();\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following excerpt from a Java program mistakenly calls run() instead of start().\n","name":"Call to Thread run() instead of start()","childOf":[821],"description":"The program calls a thread's run() method instead of calling start(), which causes the code to run in the thread of the caller instead of the callee. In most cases a direct call to a Thread object's run() method is a bug. The programmer intended to begin a new thread of control, but accidentally called run() instead of start(), so the run() method will execute in the caller's thread of control.","parentOf":[],"id":572,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    Thread thr = new Thread() {\n    \n     public void run() {\n     \n      ...\n     }\n    };\n \nthr.run();\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following Java example a Customer Entity EJB provides access to customer information in a database for a business application.\nHowever, the customer entity EJB uses the synchronized keyword for the set methods to attempt to provide thread safe synchronization for the member variables. The use of synchronized methods violate the restriction of the EJB specification against the use synchronization primitives within EJBs. Using synchronization primitives may cause inconsistent behavior of the EJB when used within different EJB containers.\n","name":"EJB Bad Practices: Use of Synchronization Primitives","childOf":[695],"description":"The program violates the Enterprise JavaBeans (EJB) specification by using thread synchronization primitives. The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: \"An enterprise bean must not use thread synchronization primitives to synchronize execution of multiple instances.\" The specification justifies this requirement in the following way: \"This rule is required to ensure consistent runtime semantics because while some EJB containers may use a single JVM to execute all enterprise bean's instances, others may distribute the instances across multiple JVMs.\"","parentOf":[],"id":574,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    @Entity\npublic class Customer implements Serializable {\n\n    \n     \n      private String id;\nprivate String firstName;\nprivate String lastName;\nprivate Address address;\n \npublic Customer() {...}\n \npublic Customer(String id, String firstName, String lastName) {...}\n \n@Id\npublic String getCustomerId() {...}\n \npublic synchronized void setCustomerId(String id) {...}\n \npublic String getFirstName() {...}\n \npublic synchronized void setFirstName(String firstName) {...}\n \npublic String getLastName() {...}\n \npublic synchronized void setLastName(String lastName) {...}\n \n@OneToOne()\npublic Address getAddress() {...}\n \npublic synchronized void setAddress(Address address) {...}\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following Java example is a simple converter class for converting US dollars to Yen. This converter class demonstrates the improper practice of using a stateless session Enterprise JavaBean that implements an AWT Component and AWT keyboard event listener to retrieve keyboard input from the user for the amount of the US dollars to convert to Yen.\nThis use of the AWT and Swing APIs within any kind of Enterprise JavaBean not only violates the restriction of the EJB specification against using AWT or Swing within an EJB but also violates the intended use of Enterprise JavaBeans to separate business logic from presentation logic.\nThe Stateless Session Enterprise JavaBean should contain only business logic. Presentation logic should be provided by some other mechanism such as Servlets or Java Server Pages (JSP) as in the following Java\/JSP example.\n","name":"EJB Bad Practices: Use of AWT Swing","childOf":[695],"description":"The program violates the Enterprise JavaBeans (EJB) specification by using AWT\/Swing. The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: \"An enterprise bean must not use the AWT functionality to attempt to output information to a display, or to input information from a keyboard.\" The specification justifies this requirement in the following way: \"Most servers do not allow direct interaction between an application program and a keyboard\/display attached to the server system.\"","parentOf":[],"id":575,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    @Stateless\npublic class ConverterSessionBean extends Component implements KeyListener, ConverterSessionRemote {\n    \n     \n \/* member variables for receiving keyboard input using AWT API *\/ \n \n...\nprivate StringBuffer enteredText = new StringBuffer();\n \n \/* conversion rate on US dollars to Yen *\/ \n \nprivate BigDecimal yenRate = new BigDecimal(\"115.3100\");\n \npublic ConverterSessionBean() {\n      \n       \n        super();\n \/* method calls for setting up AWT Component for receiving keyboard input *\/ \n \n...\naddKeyListener(this);\n       \n      }\n \npublic BigDecimal dollarToYen(BigDecimal dollars) {\n      \n       BigDecimal result = dollars.multiply(yenRate);\nreturn result.setScale(2, BigDecimal.ROUND_DOWN);\n      }\n \n \/* member functions for implementing AWT KeyListener interface *\/ \n \npublic void keyTyped(KeyEvent event) {\n      \n       ...\n      }\n \npublic void keyPressed(KeyEvent e) {\n}\n \npublic void keyReleased(KeyEvent e) {\n}\n \n \/* member functions for receiving keyboard input and displaying output *\/ \n \npublic void paint(Graphics g) {...}\n \n...\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following Java example is a simple stateless Enterprise JavaBean that retrieves the interest rate for the number of points for a mortgage. In this example, the interest rates for various points are retrieved from an XML document on the local file system, and the EJB uses the Java I\/O API to retrieve the XML document from the local file system.\nThis use of the Java I\/O API within any kind of Enterprise JavaBean violates the EJB specification by using the java.io package for accessing files within the local filesystem.\nAn Enterprise JavaBean should use a resource manager API for storing and accessing data. In the following example, the private member function getInterestRateFromXMLParser uses an XML parser API to retrieve the interest rates.\n","name":"EJB Bad Practices: Use of Java I\/O","childOf":[695],"description":"The program violates the Enterprise JavaBeans (EJB) specification by using the java.io package. The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: \"An enterprise bean must not use the java.io package to attempt to access files and directories in the file system.\" The specification justifies this requirement in the following way: \"The file system APIs are not well-suited for business components to access data. Business components should use a resource manager API, such as JDBC, to store data.\"","parentOf":[],"id":576,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    @Stateless\npublic class InterestRateBean implements InterestRateRemote {\n\n    \n     \n      private Document interestRateXMLDocument = null;\nprivate File interestRateFile = null;\n \npublic InterestRateBean() {\n      \n       \n        try {\n        \n         \n \/* get XML document from the local filesystem *\/ \ninterestRateFile = new File(Constants.INTEREST_RATE_FILE);\n \nif (interestRateFile.exists())\n{\n          \n           DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\ninterestRateXMLDocument = db.parse(interestRateFile);\n          }\n         \n        } catch (IOException ex) {...}\n       \n      }\n \npublic BigDecimal getInterestRate(Integer points) {\n      \n       return getInterestRateFromXML(points);\n      }\n \n \/* member function to retrieve interest rate from XML document on the local file system *\/ \n \nprivate BigDecimal getInterestRateFromXML(Integer points) {...}\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following Java example is a simple stateless Enterprise JavaBean that retrieves stock symbols and stock values. The Enterprise JavaBean creates a socket and listens for and accepts connections from clients on the socket.\nAnd the following Java example is similar to the previous example but demonstrates the use of multicast socket connections within an Enterprise JavaBean.\nThe previous two examples within any type of Enterprise JavaBean violate the EJB specification by attempting to listen on a socket, accepting connections on a socket, or using a socket for multicast.\n","name":"EJB Bad Practices: Use of Sockets","childOf":[573],"description":"The program violates the Enterprise JavaBeans (EJB) specification by using sockets. The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: \"An enterprise bean must not attempt to listen on a socket, accept connections on a socket, or use a socket for multicast.\" The specification justifies this requirement in the following way: \"The EJB architecture allows an enterprise bean instance to be a network socket client, but it does not allow it to be a network server. Allowing the instance to become a network server would conflict with the basic function of the enterprise bean-- to serve the EJB clients.\"","parentOf":[],"id":577,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    @Stateless\npublic class StockSymbolBean implements StockSymbolRemote {\n    \n     \nServerSocket serverSocket = null;\nSocket clientSocket = null;\n \npublic StockSymbolBean() {\n      \n       \n        try {\n        \n         serverSocket = new ServerSocket(Constants.SOCKET_PORT);\n        } catch (IOException ex) {...}\n \ntry {\n        \n         clientSocket = serverSocket.accept();\n        } catch (IOException e) {...}\n       \n      }\n \npublic String getStockSymbol(String name) {...}\n \npublic BigDecimal getStockValue(String symbol) {...}\n \nprivate void processClientInputFromSocket() {...}\n     \n    }\n   \n  \n \n"," Java\n   \n  \n  \n   \n    @Stateless\npublic class StockSymbolBean extends Thread implements StockSymbolRemote {\n    \n     \nServerSocket serverSocket = null;\nSocket clientSocket = null;\nboolean listening = false;\n \npublic StockSymbolBean() {\n      \n       \n        try {\n        \n         serverSocket = new ServerSocket(Constants.SOCKET_PORT);\n        } catch (IOException ex) {...}\n \nlistening = true;\nwhile(listening) {\n        \n         start();\n        }\n       \n      }\n \npublic String getStockSymbol(String name) {...}\n \npublic BigDecimal getStockValue(String symbol) {...}\n \npublic void run() {\n      \n       try {\n       \n        clientSocket = serverSocket.accept();\n       } catch (IOException e) {...}\n...\n      }\n\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following Java example is a simple stateless Enterprise JavaBean that retrieves the interest rate for the number of points for a mortgage. The interest rates for various points are retrieved from an XML document on the local file system, and the EJB uses the Class Loader for the EJB class to obtain the XML document from the local file system as an input stream.\nThis use of the Java Class Loader class within any kind of Enterprise JavaBean violates the restriction of the EJB specification against obtaining the current class loader as this could compromise the security of the application using the EJB.\nExample 2\nAn EJB is also restricted from creating a custom class loader and creating a class and instance of a class from the class loader, as shown in the following example.\n","name":"EJB Bad Practices: Use of Class Loader","childOf":[573],"description":"The program violates the Enterprise JavaBeans (EJB) specification by using the class loader. The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: \"The enterprise bean must not attempt to create a class loader; obtain the current class loader; set the context class loader; set security manager; create a new security manager; stop the JVM; or change the input, output, and error streams.\" The specification justifies this requirement in the following way: \"These functions are reserved for the EJB container. Allowing the enterprise bean to use these functions could compromise security and decrease the container's ability to properly manage the runtime environment.\"","parentOf":[],"id":578,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    @Stateless\npublic class InterestRateBean implements InterestRateRemote {\n\n    \n     \n      private Document interestRateXMLDocument = null;\n \npublic InterestRateBean() {\n      \n       \n        try {\n        \n         \n \/\/ get XML document from the local filesystem as an input stream \n \n \/\/ using the ClassLoader for this class \nClassLoader loader = this.getClass().getClassLoader();\nInputStream in = loader.getResourceAsStream(Constants.INTEREST_RATE_FILE);\n         \n        \n       \n       \n \nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      \n       DocumentBuilder db = dbf.newDocumentBuilder();\ninterestRateXMLDocument = db.parse(interestRateFile);\n      } catch (IOException ex) {...}\n     \n    }\n\n    \n     \n      public BigDecimal getInterestRate(Integer points) {\n      \n       return getInterestRateFromXML(points);\n      }\n \n \/* member function to retrieve interest rate from XML document on the local file system *\/ \n \nprivate BigDecimal getInterestRateFromXML(Integer points) {...}\n     \n    }\n   \n  \n \n"," Java\n   \n  \n  \n   \n    @Stateless\npublic class LoaderSessionBean implements LoaderSessionRemote {\n\n    \n     \n      public LoaderSessionBean() {\n      \n       try {\n       \n        ClassLoader loader = new CustomClassLoader();\nClass c = loader.loadClass(\"someClass\");\nObject obj = c.newInstance();\n\/* perform some task that uses the new class instance member variables or functions *\/\n...\n       } catch (Exception ex) {...}\n      }\n \npublic class CustomClassLoader extends ClassLoader {\n \n}\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following class adds itself to the session, but because it is not serializable, the session can no longer be replicated.\n","name":"J2EE Bad Practices: Non","childOf":[573],"description":"The application stores a non-serializable object as an HttpSession attribute, which can hurt reliability. A J2EE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the J2EE container can replicate an HttpSession object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application. This is only possible if all session data is serializable, allowing the session to be duplicated between the JVMs.","parentOf":[],"id":579,"memberOf":[1018],"exampleCode":[" Java\n   \n  \n  \n   \n    public class DataGlob {\n    \n     \n      String globName;\nString globValue;\n \npublic void addToSession(HttpSession session) {\n      \n       session.setAttribute(\"glob\", this);\n      }\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following two classes demonstrate a bug introduced by not calling super.clone(). Because of the way Kibitzer implements clone(), FancyKibitzer's clone method will return an object of type Kibitzer instead of FancyKibitzer.\n","name":"clone() Method Without super.clone()","childOf":[573],"description":"The software contains a clone() method that does not call super.clone() to obtain the new object. All implementations of clone() should obtain the new object by calling super.clone(). If a class does not follow this convention, a subclass's clone() method will return an object of the wrong type.","parentOf":[],"id":580,"memberOf":[265],"exampleCode":[" Java\n   \n  \n  \n   \n    public class Kibitzer {\n    \n     \n      public Object clone() throws CloneNotSupportedException {\n      \n       \nObject returnMe = new Kibitzer();\n...\n       \n      }\n     \n    }\n \npublic class FancyKibitzer extends Kibitzer{\n    \n     \n      public Object clone() throws CloneNotSupportedException {\n      \n       \nObject returnMe = super.clone();\n...\n       \n      }\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"","name":"Object Model Violation: Just One of Equals and Hashcode Defined","childOf":[697],"description":"The software does not maintain equal hashcodes for equal objects. Java objects are expected to obey a number of invariants related to equality. One of these invariants is that equal objects must have equal hashcodes. In other words, if a.equals(b) == true then a.hashCode() == b.hashCode().","parentOf":[],"id":581,"memberOf":[1006],"exampleCode":[]},{"exampleDescription":"Example 1\nThe following Java Applet code mistakenly declares an array public, final and static.\n","name":"Array Declared Public, Final, and Static","childOf":[668],"description":"The program declares an array public, final, and static, which is not sufficient to prevent the array's contents from being modified. Because arrays are mutable objects, the final constraint requires that the array object itself be assigned only once, but makes no guarantees about the values of the array elements. Since the array is public, a malicious program can change the values stored in the array. As such, in most cases an array declared public, final and static is a bug.","parentOf":[],"id":582,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public final class urlTool extends Applet {\n    \n     public final static URL[] urls;\n...\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following Java Applet code mistakenly declares a public finalize() method.\nMobile code, in this case a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your program is running.\n","name":"finalize() Method Declared Public","childOf":[668],"description":"The program violates secure coding principles for mobile code by declaring a finalize() method public. A program should never call finalize explicitly, except to call super.finalize() inside an implementation of finalize(). In mobile code situations, the otherwise error prone practice of manual garbage collection can become a security threat if an attacker can maliciously invoke a finalize() method because it is declared with public access.","parentOf":[],"id":583,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public final class urlTool extends Applet {\n    \n     public void finalize() {\n     \n      ...\n     }\n...\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following code attempts to synchronize on an object, but does not execute anything in the synchronized block. This does not actually accomplish anything and may be a sign that a programmer is wrestling with synchronization but has not yet achieved the result they intend.\nInstead, in a correct usage, the synchronized statement should contain procedures that access or modify data that is exposed to multiple threads. For example, consider a scenario in which several threads are accessing student records at the same time. The method which sets the student ID to a new value will need to make sure that nobody else is accessing this data at the same time and will require synchronization.\n","name":"Empty Synchronized Block","childOf":[1071],"description":"The software contains an empty synchronized block. An empty synchronized block does not actually accomplish any synchronization and may indicate a troubled section of code. An empty synchronized block can occur because code no longer needed within the synchronized block is commented out without removing the synchronized block.","parentOf":[],"id":585,"memberOf":[557],"exampleCode":[" Java\n   \n  \n  \n   \n    synchronized(this) { }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following code fragment calls finalize() explicitly:\n","name":"Explicit Call to Finalize()","childOf":[1076],"description":"The software makes an explicit call to the finalize() method from outside the finalizer. While the Java Language Specification allows an object's finalize() method to be called from outside the finalizer, doing so is usually a bad idea. For example, calling finalize() explicitly means that finalize() will be called more than once: the first time will be the explicit call and the last time will be the call that is made after the object is garbage collected.","parentOf":[],"id":586,"memberOf":[1006],"exampleCode":[" Java\n   \n  \n  \n   \n \/\/ time to clean up \nwidget.finalize();\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following Java example, a Customer Entity JavaBean provides access to customer information in a database for a business application. The Customer Entity JavaBean is used as a session scoped object to return customer information to a Session EJB.\nHowever, the Customer Entity JavaBean is an unserialized object which can cause serialization failure and crash the application when the J2EE container attempts to write the object to the system. Session scoped objects must implement the Serializable interface to ensure that the objects serialize properly.\n","name":"J2EE Framework: Saving Unserializable Objects to Disk","childOf":[710],"description":"When the J2EE container attempts to write unserializable objects to disk there is no guarantee that the process will complete successfully. In heavy load conditions, most J2EE application frameworks flush objects to disk to manage memory requirements of incoming requests. For example, session scoped objects, and even application scoped objects, are written to disk when required. While these application frameworks do the real work of writing objects to disk, they do not enforce that those objects be serializable, thus leaving the web application vulnerable to crashes induced by serialization failure. An attacker may be able to mount a denial of service attack by sending enough requests to the server to force the web application to save objects to disk.","parentOf":[],"id":594,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    @Entity\npublic class Customer {\n\n    \n     \n      private String id;\nprivate String firstName;\nprivate String lastName;\nprivate Address address;\n \npublic Customer() {\n}\n \npublic Customer(String id, String firstName, String lastName) {...}\n \n@Id\npublic String getCustomerId() {...}\n \npublic void setCustomerId(String id) {...}\n \npublic String getFirstName() {...}\n \npublic void setFirstName(String firstName) {...}\n \npublic String getLastName() {...}\n \npublic void setLastName(String lastName) {...}\n \n@OneToOne()\npublic Address getAddress() {...}\n \npublic void setAddress(Address address) {...}\n     \n     \n \n}\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the example below, two Java String objects are declared and initialized with the same string values. An if statement is used to determine if the strings are equivalent.\nHowever, the if statement will not be executed as the strings are compared using the \"==\" operator. For Java objects, such as String objects, the \"==\" operator compares object references, not object values. While the two String objects above contain the same string values, they refer to different object references, so the System.out.println statement will not be executed. To compare object values, the previous code could be modified to use the equals method:\nExample 2\nIn the following Java example, two BankAccount objects are compared in the isSameAccount method using the == operator.\nUsing the == operator to compare objects may produce incorrect or deceptive results by comparing object references rather than values. The equals() method should be used to ensure correct results or objects should contain a member variable that uniquely identifies the object.\nThe following example shows the use of the equals() method to compare the BankAccount objects and the next example uses a class get method to retrieve the bank account number that uniquely identifies the BankAccount object to compare the objects.\n","name":"Comparison of Object References Instead of Object Contents","childOf":[1025],"description":"The program compares object references instead of the contents of the objects themselves, preventing it from detecting equivalent objects. For example, in Java, comparing objects using == usually produces deceptive results, since the == operator compares object references rather than values; often, this means that using == for strings is actually comparing the strings' references, not their values.","parentOf":[597],"id":595,"memberOf":[569],"exampleCode":[" Java\n   \n  \n  \n   \n    String str1 = new String(\"Hello\");\nString str2 = new String(\"Hello\");\nif (str1 == str2) {\n    \n     System.out.println(\"str1 == str2\");\n    }\n   \n  \n \n"," Java\n   \n  \n  \n   \n    public boolean isSameAccount(BankAccount accountA, BankAccount accountB) {\n    \n     return accountA == accountB;\n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nHere, an array (which is inherently mutable) is labeled public static final.\n","name":"Public Static Final Field References Mutable Object","childOf":[471],"description":"A public or protected static final field references a mutable object, which allows the object to be changed by malicious code, or accidentally from another package. ","parentOf":[],"id":607,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public static final String[] USER_ROLES;\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIn the following Java example the class RegistrationForm is a Struts framework ActionForm Bean that will maintain user input data from a registration webpage for a online business site. The user will enter registration data and through the Struts framework the RegistrationForm bean will maintain the user data.\nHowever, within the RegistrationForm the member variables for the registration form input data are declared public not private. All member variables within a Struts framework ActionForm class must be declared private to prevent the member variables from being modified without using the getter and setter methods. The following example shows the member variables being declared private and getter and setter methods declared for accessing the member variables.\n","name":"Struts: Non","childOf":[668],"description":"An ActionForm class contains a field that has not been declared private, which can be accessed without using a setter or getter. ","parentOf":[],"id":608,"memberOf":[],"exampleCode":[" Java\n   \n  \n  \n   \n    public class RegistrationForm extends org.apache.struts.validator.ValidatorForm {\n\n    \n     \n      \/\/ variables for registration form\npublic String name;\npublic String email;\n...\n \npublic RegistrationForm() {\n      \n       super();\n      }\npublic ActionErrors validate(ActionMapping mapping, HttpServletRequest request) {...}\n...\n     \n    }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nIt may seem that the following bit of code achieves thread safety while avoiding unnecessary synchronization...\nThe programmer wants to guarantee that only one Helper() object is ever allocated, but does not want to pay the cost of synchronization every time this code is called.\nSuppose that helper is not initialized. Then, thread A sees that helper==null and enters the synchronized block and begins to execute:\nIf a second thread, thread B, takes over in the middle of this call and helper has not finished running the constructor, then thread B may make calls on helper while its fields hold incorrect values.\n","name":"Double","childOf":[667],"description":"The program uses double-checked locking to access a resource without the overhead of explicit synchronization, but the locking is insufficient. Double-checked locking refers to the situation where a programmer checks to see if a resource has been initialized, grabs a lock, checks again to see if the resource has been initialized, and then performs the initialization if it has not occurred yet. This should not be done, as is not guaranteed to work in all languages and on all architectures. In summary, other threads may not be operating inside the synchronous block and are not guaranteed to see the operations execute in the same order as they would appear inside the synchronous block.","parentOf":[],"id":609,"memberOf":[411],"exampleCode":[" Java\n   \n  \n  \n   \n    if (helper == null) {\n    \n     \n      synchronized (this) {\n      \n       if (helper == null) {\n       \n        helper = new Helper();\n       }\n      }\n     \n    }\nreturn helper;\n   \n  \n \n"]},{"exampleDescription":"Example 1\nThe following example declares a critical variable public, making it accessible to anyone with access to the object in which it is contained.\nInstead, the critical data should be declared private.\nEven though this example declares the password to be private, there are other possible issues with this implementation, such as the possibility of recovering the password from process memory (CWE-257).\nExample 2\nThe following example shows a basic user account class that includes member variables for the username and password as well as a public constructor for the class and a public method to authorize access to the user account.\nHowever, the member variables username and password are declared public and therefore will allow access and changes to the member variables to anyone with access to the object. These member variables should be declared private as shown below to prevent unauthorized access and changes.\n","name":"Critical Data Element Declared Public","childOf":[1061],"description":"The software declares a critical variable, field, or member to be public when intended security policy requires it to be private. This issue makes it more difficult to maintain the software, which indirectly affects security by making it more difficult or time-consuming to find and\/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.","parentOf":[],"id":766,"memberOf":[275],"exampleCode":[" C++\n   \n  \n  \n   \n    public"," C++\n   \n  \n  \n   \n    #define MAX_PASSWORD_LENGTH 15\n#define MAX_USERNAME_LENGTH 15\n \nclass UserAccount\n{\n    \n     \n      public"]},{"exampleDescription":"Example 1\nThe following example declares a critical variable to be private, and then allows the variable to be modified by public methods.\nExample 2\nThe following example could be used to implement a user forum where a single user (UID) can switch between multiple profiles (PID).\nThe programmer implemented setPID with the intention of modifying the PID variable, but due to a typo. accidentally specified the critical variable UID instead. If the program allows profile IDs to be between 1 and 10, but a UID of 1 means the user is treated as an admin, then a user could gain administrative privileges as a result of this typo.\n","name":"Access to Critical Private Variable via Public Method","childOf":[668],"description":"The software defines a public method that reads or modifies a private variable. If an attacker modifies the variable to contain unexpected values, this could violate assumptions from other parts of the code. Additionally, if an attacker can read the private variable, it may expose sensitive information or make it easier to launch further attacks.","parentOf":[],"id":767,"memberOf":[275],"exampleCode":[" C++\n   \n  \n  \n   \n    private"," Java\n   \n  \n  \n   \n    public class Client {\n    \n     private int UID;\npublic int PID;\nprivate String userName;\npublic Client(String userName){\n     \n      PID = getDefaultProfileID();\nUID = mapUserNametoUID( userName );\nthis.userName = userName;\n     }\npublic void setPID(int ID) {\n     \n      UID = ID;\n     }\n    }\n   \n  \n \n"]},{"exampleDescription":"","name":"Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')","childOf":[77,74,77,77],"description":"The software constructs all or part of an expression language (EL) statement in a framework such as a Java Server Page (JSP) using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended EL statement before it is executed. Frameworks such as Java Server Page (JSP) allow a developer to insert executable expressions within otherwise-static content. When the developer is not aware of the executable nature of these expressions and\/or does not disable them, then if an attacker can inject expressions, this could lead to code execution or other unexpected behaviors.","parentOf":[],"id":917,"memberOf":[137],"exampleCode":[]},{"exampleDescription":"Example 1\nJava has a boxed primitive for each primitive type. A long can be represented with the boxed primitive Long. Issues arise where boxed primitives are used when not strictly necessary.\nIn the above loop, we see that the count variable is declared as a boxed primitive. This causes autoboxing on the line that increments. This causes execution to be magnitudes less performant (time and possibly space) than if the \"long\" primitive was used to declare the count variable, which can impact availability of a resource.\nExample 2\nThis code uses primitive long which fixes the issue.\n","name":"Incorrect Use of Autoboxing and Unboxing for Performance Critical Operations","childOf":[400],"description":"The code uses boxed primitives, which may introduce inefficiencies into performance-critical operations. Languages such as Java and C# support automatic conversion through their respective compilers from primitive types into objects of the corresponding wrapper classes, and vice versa. For example, a compiler might convert an int to Integer (called autoboxing) or an Integer to int (called unboxing). This eliminates forcing the programmer to perform these conversions manually, which makes the code cleaner. However, this feature comes at a cost of performance and can lead to resource exhaustion and impact availability when used with generic collections. Therefore, they should not be used for scientific computing or other performance critical operations. They are only suited to support \"impedance mismatch\" between reference types and primitives.","parentOf":[],"id":1235,"memberOf":[1006],"exampleCode":[" Java\n   \n  \n  \n   \n    Long count = 0L; \n for (long i = 0; i < Integer.MAX_VALUE; i++) { \n    \n     count += i; \n\n     }\n   \n  \n \n"]},{"exampleDescription":"Example 1\nA negative shift amount for an x86 or x86_64 shift instruction will produce the number of bits to be shifted by taking a 2's-complement of the shift amount and effectively masking that amount to the lowest 6 bits for a 64 bit shift instruction.\nThe example above ends up with a shift amount of -5. The hexadecimal value is FFFFFFFFFFFFFFFD which, when bits above the 6th bit are masked off, the shift amount becomes a binary shift value of 111101 which is 61 decimal. A shift of 61 produces a very different result than -5. The previous example is a very simple version of the following code which is probably more realistic of what happens in a real system.\nNote that the good example not only checks for negative shifts and disallows them, but it also checks for over-shifts. No bit operation is done if the shift is out of bounds. Depending on the program, perhaps an error message should be logged.\n","name":"Incorrect Bitwise Shift of Integer","childOf":[682],"description":"An integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result. Specifying a value to be shifted by a negative amount is undefined in various languages. Various computer architectures implement this action in different ways. The compilers and interpreters when generating code to accomplish a shift generally do not do a check for this issue. Specifying an over-shift, a shift greater than or equal to the number of bits contained in a value to be shifted, produces a result which varies by architecture and compiler. In some languages, this action is specifically listed as producing an undefined result.","parentOf":[],"id":1335,"memberOf":[],"exampleCode":[" C\n   \n  \n  \n   unsigned int r = 1 << -5;\n  \n \n"," C\n   \n  \n  \n   int choose_bit(int reg_bit, int bit_number_from_elsewhere) \n {\n\n   \n    if (NEED_TO_SHIFT)\n {\n\n    \n     reg_bit -= bit_number_from_elsewhere;\n\n     }\n return reg_bit;\n\n    }\n unsigned int handle_io_register(unsigned int *r)\n {\n\n   \n    unsigned int the_bit = 1 << choose_bit(5, 10);\n *r |= the_bit;\n return the_bit;\n\n    }\n  \n \n"]},{"exampleDescription":"","name":"Improper Neutralization of Special Elements Used in a Template Engine","childOf":[94],"description":"The product uses a template engine to insert or process externally-influenced input, but it does not neutralize or incorrectly neutralizes special elements or syntax that can be interpreted as template expressions or other code directives when processed by the engine. Many web applications use template engines that allow developers to insert externally-influenced values into free text or messages in order to generate a full web page, document, message, etc. Such engines include Twig, Jinja2, Pug, Java Server Pages, FreeMarker, Velocity, ColdFusion, Smarty, and many others - including PHP itself. Some CMS (Content Management Systems) also use templates. Template engines often have their own custom command or expression language. If an attacker can influence input into a template before it is processed, then the attacker can invoke arbitrary expressions, i.e. perform injection attacks. For example, in some template languages, an attacker could inject the expression \"{{7*7}}\" and determine if the output returns \"49\" instead. The syntax varies depending on the language. In some cases, XSS-style attacks can work, which can obscure the root cause if the developer does not closely investigate the root cause of the error. Template engines can be used on the server or client, so both \"sides\" could be affected by injection. The mechanisms of attack or the affected technologies might be different, but the mistake is fundamentally the same.","parentOf":[],"id":1336,"memberOf":[],"exampleCode":[]},{"exampleDescription":"Example 1\nThis example attempts to close a file twice. In some cases, the C library fclose() function will catch the error and return an error code. In other implementations, a double-free (CWE-415) occurs, causing the program to fault. Note that the examples presented here are simplistic, and double fclose() calls will frequently be spread around a program, making them more difficult to find during code reviews.\nThere are multiple possible fixes. This fix only has one call to fclose(), which is typically the preferred handling of this problem - but this simplistic method is not always possible.\nThis fix uses a flag to call fclose() only once. Note that this flag is explicit. The variable \"f\" could also have been used as it will be either NULL if the file is not able to be opened or a valid pointer if the file was successfully opened. If \"f\" is replacing \"f_flg\" then \"f\" would need to be set to NULL after the first fclose() call so the second fclose call would never be executed.\nExample 2\nThe following code shows a simple example of a double free vulnerability.\nDouble free vulnerabilities have two common (and sometimes overlapping) causes:\n\n\nAlthough some double free vulnerabilities are not much more complicated than this example, most are spread out across hundreds of lines of code or even different files. Programmers seem particularly susceptible to freeing global variables more than once.\n","name":"Multiple Releases of Same Resource or Handle","childOf":[675],"description":"The product attempts to close or release a resource or handle more than once, without any successful open between the close operations. Code typically requires \"opening\" handles or references to resources such as memory, files, devices, socket connections, services, etc. When the code is finished with using the resource, it is typically expected to \"close\" or \"release\" the resource, which indicates to the environment (such as the OS) that the resource can be re-assigned or reused by unrelated processes or actors - or in some cases, within the same process. API functions or other abstractions are often used to perform this release, such as free() or delete() within C\/C++, or file-handle close() operations that are used in many languages. Unfortunately, the implementation or design of such APIs might expect the developer to be responsible for ensuring that such APIs are only called once per release of the resource. If the developer attempts to release the same resource\/handle more than once, then the API's expectations are not met, resulting in undefined and\/or insecure behavior. This could lead to consequences such as memory corruption, data corruption, execution path corruption, or other consequences. Note that while the implementation for most (if not all) resource reservation allocations involve a unique identifier\/pointer\/symbolic reference, then if this identifier is reused, checking the identifier for resource closure may result in a false state of openness and closing of the wrong resource. For this reason, reuse of identifiers is discouraged.","parentOf":[],"id":1341,"memberOf":[],"exampleCode":[" C\n   \n  \n  \n   char b[2000];\n FILE *f = fopen(\"dbl_cls.c\", \"r\");\n if (f)\n {\n\n   \n    b[0] = 0;\n fread(b, 1, sizeof(b) - 1, f);\n printf(\"%s\\n'\", b);\n int r1 = fclose(f);\n printf(\"\\n-----------------\\n1 close done '%d'\\n\", r1);\n\n int r2 = fclose(f); \/\/ Double close\n printf(\"2 close done '%d'\\n\", r2);\n    }\n  \n \n"," C\n   \n  \n  \n   \n    char* ptr = (char*)malloc (SIZE);\n...\nif (abrt) {\n    \n     free(ptr);\n    }\n...\nfree(ptr);\n   \n  \n \n"]}]